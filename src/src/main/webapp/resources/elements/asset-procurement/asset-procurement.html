<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../fastclick/fastclick.html">
<link rel="import" href="../modernizr/modernizr.html">
<link rel="import" href="asset-procurement-styles.html">
<script src="../../bower_components/d3-transform/src/d3-transform.js"></script>
<script src="../../bower_components/urijs/src/URI.js"></script>

<dom-module id="asset-procurement">
  <template>
    <style include="asset-procurement-styles"></style>
    <div id="chart" class="chart-container">
      <svg id="svg" width$="[[width]]" height$="[[height]]"></svg>
    </div>
  </template>
  <script>
    function getDefaultConf() {
      return {
        circleThickness: 1, // The outer circle stroke width
        circleColor: 'rgb(168,167,166)', // The color of the outer circle.
        waveHeight: 0.05, // The wave height as a percentage of wave circle's radius
        waveCount: 1, // The number of full waves per width of the wave circle.
        waveColor: 'rgb(168,167,166)', // The color of the fill wave.
        textColor: '#fff', // The color of the value text when the wave does not overlap it.
        waveTextColor: '#A4DBf8' // The color of the value text when the wave overlaps it.
      }
    }

    Polymer({
      is: 'asset-procurement',
      properties: {
        width: Number,
        height: Number,
        data: Object
      },
      behaviors: [
        Polymer.IronResizableBehavior
      ],
      listeners: {
        'iron-resize': 'handleResize'
      },
      observers: [
        'redraw(width, height, data)'
      ],
      handleResize: function() {
        var rect = this.$.chart.getBoundingClientRect();
        this.set('width', rect.width);
        this.set('height', rect.height);
      },
      loadData: function() {
        return fetch('mock/asset-procurement.json')
        .then(function(res) {
          return res.json();
        }).then((function(data) {
          this.data = data;
        }).bind(this));
      },
      redraw: function() {
        this.$.svg.innerHTML = '';
        this.debounce('redraw', this.render, 500);
      },
      render: function() {
        var svg = d3.select(this.$.svg);
        var margin = 20;
        var diameter = Math.min.call(null, this.width, this.height);

        var g = svg.append('g')
        .attr('transform', d3Transform().translate(this.width / 2, this.height / 2));

        var pack = d3.pack()
        .size([diameter - margin, diameter - margin])
        .padding(2);
        
        var root = d3.hierarchy(this.data)
        .sum(function(d) { return d.size; })
        .sort(function(a, b) { return b.value - a.value; })

        var focus = root;
        var nodes = pack(root).descendants();
        var view;

        var assetGroup = g
        .selectAll('g')
        .data(nodes)
        .enter().append('g')
        .attr('class', 'asset')
        // .style('display', function(d) {
        //   return d.parent === root ? 'inline' : 'none';
        // });

        assetGroup        
        .append('circle')
        .attr('r', function(d) {
          return d.r;
        })
        .attr('class', function(d) {
          return d.parent ? d.children ? 'node' : 'node node--leaf' : 'node node--root';
        })
        .attr('id', function(d) {
          return 'circle-' + d.data.id;
        })
        .attr('stroke-width', 1)
        .attr('stroke', 'white')
        .attr('fill', function(d) {
          return (d !== focus && d.parent !== focus) ? 'none' : 'black';
        })
        .on('click', function(d) {
          if (focus !== d) {
            zoom(d);
            d3.event.stopPropagation();
          }
        });

        var config = getDefaultConf();

        assetGroup.each(renderWave);

        var text = g.append('g')
        .selectAll('text')
        .data(nodes)
        .enter().append('text')
        .attr('pointer-events', 'none')
        .attr('text-anchor', 'middle')
        .attr('fill', config.textColor)
        .attr('dy', '.35em')
        .attr('font-size', '20px')
        .style('user-select', 'none')
        .style('fill-opacity', function(d) {
          return (d === root || d.parent === root) ? 1 : 0;
        })
        .style('display', function(d) {
          return (d === root || d.parent === root) ? 'inline' : 'none';
        })
        .text(function(d) {
          return parseInt(d.data.usage* 100) + '%'
        })
        // .style('display', function(d) { return d.parent === root ? 'inline' : 'none'; })
        // .append('tspan')
        // .text(function(d) {
        //   return parseInt(d.data.usage* 100) + '%'
        // })
        // .append('tspan')
        // .text(function(d) {
        //   return d.data.name
        // })

        svg.on('click', function() {
          zoom(root);
        });

        zoomTo([root.x, root.y, root.r * 2 + margin]);

        function zoom(d) {
          var focus0 = focus;
          focus = d;

          var transition = d3.transition()
          .duration(d3.event.altKey ? 7500 : 750)
          .tween('zoom', function () {
            var i = d3.interpolateZoom(view, [focus.x, focus.y, focus.r * 2 + margin]);
            return function (t) {
              zoomTo(i(t));
            }
          });

          transition.selectAll('text')
          .filter(function(d) {
            return d === focus || d.parent === focus || this.style.display === 'inline';
          })
          .style('fill-opacity', function(d) {
            return (d === focus || d.parent === focus) ? 1 : 0;
          })
          .on('start', function(d) {
            if (d === focus || d.parent === focus) this.style.display = 'inline';
          })
          .on('end', function(d) {
            if (d !== focus && d.parent !== focus) this.style.display = 'none';
          });

          transition.selectAll('circle.node--leaf')
          .attr('fill', function(d) {
            return (d !== focus && d.parent !== focus) ? 'none' : 'black';
          })

          // .style('fill-opacity', function(d) {
          //   return (d === focus || d.parent === focus) ? 1 : 0;
          // })
          // .on('start', function(d) {
          //   if (d === focus || d.parent === focus) this.style.display = 'inline';
          // })
          // .on('end', function(d) {
          //   if (d !== focus && d.parent !== focus) this.style.display = 'none';
          // });
        }

        function zoomTo(v) {
          var k = diameter / v[2];
          view = v;

          text.attr('transform', function (d) {
            return 'translate(' + (d.x - v[0]) * k + ',' + (d.y - v[1]) * k + ')';
          })

          assetGroup
          .attr('transform-origin', '50% 50%')
          .attr('transform', function (d) {
            return 'translate(' + (d.x - v[0]) * k + ',' + (d.y - v[1]) * k + ')';
          })
          .style('opacity', function(d) {
            if (d === focus) {
              if (d.children) return 0.5;
              return 1;
            } else {
              if (d.parent === focus) return 1;
              return 0.5;
            }
            return d === focus ? 0.5 : (d.parent === focus ? 1 : 0.5);
            // return d === focus ? 0.75 : (d.parent === focus ? 1 : 0.5);
          })
          .selectAll('circle')
          .attr('transform', 'scale(' + k + ')')
        }

        function renderWave(node) {
          var assetGroup = d3.select(this)

          var radius = node.r
          var elementId = node.data.id
          var value = node.data.usage * 100

          var fillPercent = Math.max(0, Math.min(100, value)) / 100

          var circleThickness = config.circleThickness

          var fillCircleMargin = circleThickness
          var fillCircleRadius = radius

          assetGroup.append('circle')
          .attr('fill', config.waveColor)
          .attr('r', radius)
          .attr('pointer-events', 'none')
          .attr('clip-path', 'url(#clipWave' + elementId + ')')

          // Wave clip effect
          var waveHeight = fillCircleRadius * config.waveHeight

          var waveLength = fillCircleRadius * 2 / config.waveCount
          var waveClipCount = 1 + config.waveCount
          var waveClipWidth = waveLength * waveClipCount

          // Scales for controlling the size of the clipping path.
          var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1])
          var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1])

          // The clipping wave area.
          var clipArea = d3.area()
          .x(function (d) {
            return waveScaleX(d.x)
          })
          .y0(function (d) {
            return waveScaleY(Math.sin((1 - config.waveCount + d.y) * Math.PI * 2))
          })
          .y1(function (d) {
            return fillCircleRadius * 2 + waveHeight
          })

          // Data for building the clip wave area.
          var data = []
          for (var i = 0; i <= 40 * waveClipCount; i++) {
            data.push({
              x: i / (40 * waveClipCount),
              y: i / 40
            })
          }

          var waveGroup = assetGroup.append('defs')
          .append('clipPath')
          .attr('id', 'clipWave' + elementId)

          waveGroup.append('path')
          .datum(data)
          .attr('d', clipArea)
          .attr('T', 0)

          var waveRiseScale = d3.scaleLinear()
          .range([
            fillCircleMargin + fillCircleRadius + waveHeight,
            -(fillCircleMargin + fillCircleRadius - waveHeight)
          ])
          .domain([0, 1])

          var waveGroupXPosition = fillCircleMargin + fillCircleRadius - waveClipWidth
          waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
        }
      },
      ready: function() {
        this.loadData();
      }
    })
  </script>
</dom-module>