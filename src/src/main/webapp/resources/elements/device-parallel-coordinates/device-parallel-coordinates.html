<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="device-parallel-coordinates-styles.html">
<script src="../../bower_components/d3-transform/src/d3-transform.js"></script>


<dom-module id="device-parallel-coordinates">
  <template>
    <style include="device-parallel-coordinates-styles"></style>
    <div id="chart" class="canvas">
      <svg id="svg" width$="[[width]]" height$="[[height]]"></svg>
    </div>
  </template>
  <script>
    define('device-parallel-coordinates', ['context'], function(context) {

      var SECTOR_MIN_STEP_FACTOR = .1;
      var $ = d3.select;

      function ellipsis(d) {
        // tspan text ellipsis to "width" attr
        var self = $(this),
          textLength = this.getComputedTextLength(),
          text = self.text();

        while ((
          textLength > self.attr('width')
        ) && text.length > 0) {
          text = text.slice(0, -1);
          self.text(text + '...');
          textLength = this.getComputedTextLength();
        }
      }

      Polymer({
        is: 'device-parallel-coordinates',
        properties: {
          width: Number,
          height: Number,
          margin: {
            type: Object,
            value: function() {
              return {
                top: 40,
                right: 40,
                bottom: 20,
                left: 40
              };
            },
          },
          dimensions: {
            type: Array,
            computed: '_getDimensions(data, margin, height)'
          },
          data: Array,
        },
        observers: [
          '_replot(width, height, data)'
        ],
        behaviors: [
          Polymer.IronResizableBehavior
        ],
        listeners: {
          'iron-resize': '_onResize'
        },
        render: function() {
          var _this = this;
          var margin = this.margin,
            width = this.width - margin.left - margin.right,
            height = this.height - margin.top - margin.bottom;

          var svg = d3.select(this.$.svg);

          var dimensions = this.dimensions;
          var data = this.data;

          var x = d3.scalePoint()
          .domain(dimensions.map(function(d) {
            return d.name;
          }))
          .padding([.5])
          .range([0, width]);

          var line = d3.line()
          .curve(d3.curveMonotoneX)
          .defined(function(d) { return !isNaN(d[1]); });
          var yAxis = d3.axisLeft();

          var root = svg.append("g").classed('chart-body', true).attr('transform', d3Transform().translate(margin.left, margin.top));

          var dimension = root.selectAll(".dimension")
          .data(dimensions)
          .enter().append("g")
          .attr("class", "dimension")
          .attr("transform", d3Transform().translate(function(d) {
            return [x(d.name), 0]
          }));

          // massage dimension with scale definitions (rules)
          dimensions.forEach(function(dimension) {
            var domain;
            var scaleDef = _this.scales;
            var extent;
            var ticks;
            // the measurement axis
            if (dimension.type === Number) {
              extent = scaleDef[dimension.name];
              domain = [extent.min, extent.max];
            }
            // the ordinal axis
            else {
              domain = data.map(function(d) {
                return d[dimension.name];
              });
            }
            dimension.scale.domain(domain);
            if (ticks) {
              dimension.scale.ticks(ticks);
            }
          });

          root.append("g")
          .attr("class", "background")
          .selectAll("path")
          .data(data)
          .enter().append("path")
          .attr("d", draw);

          root.append("g")
          .attr("class", "foreground")
          .selectAll("path")
          .data(data)
          .enter().append("path")
          .attr("d", draw);

          var axis = dimension.append("g")
          .attr("class", function(d) {
            return ['axis', 'axis-' + d.name].join(' ');
          });

          axis.append('text')
          .attr("class", "title")
          .attr("y", -20)
          .text(function(d) {
            return d.label;
          });

          axis.each(function(d) {
            var scale = d.scale;
            switch(d.name) {
              case 'name':
                d3.select(this).call(_this._renderDeviceList.bind(_this), d, height);
                break;
              default:
                d3.select(this).call(_this._renderDimension.bind(_this), d, height);
            }
          });

          // Rebind the axis data to simplify mouseover.
          root.select(".axis").selectAll("text:not(.title)")
          .attr("class", "label")
          .data(data, function(d) { return d.name || d; });

          var projection = root.selectAll(".axis .sector,.background path,.foreground path")
          .on("mouseover", mouseover)
          .on("mouseout", mouseout);

          this.scopeSubtree(this.$.svg);

          function mouseover(d) {
            root.classed("active", true);
            projection.classed("active", function(p) { return p === d; });
            projection.filter(function(p) { return p === d; }).each(moveToFront);

            // highlight one series
            if(d.id)
              _this._highlightSeries(d.id);
            // highlight one sector
            else if(d.value) {
              _this._highlightSector(d);
            }
          }

          function mouseout(d) {
            root.classed("active", false);
            projection.classed("inactive", false);
          }

          function moveToFront() {
            this.parentNode.appendChild(this);
          }

          function draw(d) {
            return line(dimensions.map(function(dimension) {
              return [x(dimension.name), dimension.scale(d[dimension.name])];
            }));
          }
        },
        _renderDeviceList: function(selection, dimension, height) {
          var scale = dimension.scale;
          var devices = selection.selectAll('.sector').data(this.data);
          var devicesEnter = devices.enter()
          .append('text')
          .text(function(d) {
            return d.name;
          })
          .attr('id', function(d) {
            return ['axis-label', dimension.name, d.id].join('-');
          })
          .attr('dy', '.35em')
          .attr('class', 'label')
          .attr('transform', d3Transform().translate(function(d) {
            return [0, scale(d.name)];
          }));
        },
        _renderDimension: function(selection, dimension, height) {
          function tickData(tick) {
            return {
              tick: tick,
              value: scale(tick)
            };
          }

          function notNull(val) {
            return val !== null;
          }

          function asc(a, b) {
            return a - b;
          }

          var scale = dimension.scale;
          var dimension = selection.data()[0];
          var domain = scale.domain();
          var scaleDef = this.scales;
          var extent = scaleDef[dimension.name];
          var format = dimension.format || function(val) { return val; };
          var span = extent.max - extent.min;
          var tickNum = Math.round(( span ) / extent.step);

          // unique sorted ticks
          var ticks = d3.set(
            Array.prototype.concat.call([],
              domain[0],
              scale.ticks(tickNum),
              domain[1])
          )
          .values()
          .map(Number)
          .sort(asc);

          // merge small chunk together
          var step;
          var lastTick;
          for (var i = 0, tick, length = ticks.length; tick = ticks[i], i < length; i++) {
            if (i === 0) {
              continue;
            }
            lastTick = ticks[i - 1];
            step = tick - lastTick;
            if (step < span * SECTOR_MIN_STEP_FACTOR) {
              if (i === length - 1) {
                ticks.splice(i - 1, 1);
                break;
              } else {
                ticks.splice(i, 1);
                length--;
                i--;
              }
            }
          }

          var data = ticks.map(function(tick, i) {
            var lastTick = ticks[i - 1];
            if (i === 0) {
              return null;
            } else {
              return {
                name: dimension.name,
                lastValue: lastTick,
                value: tick,
                y0: scale(lastTick),
                y1: scale(tick)
              };
            }
          }).filter(notNull);

          var sectors = selection.selectAll('.sector').data(data);
          var sectorsEnter = sectors.enter()
          .append('g')
          .attr('class', 'sector')
          .attr('transform', d3Transform().translate(function(d) {
            return [0, d.y1];
          }));

          var bar_w = 24;
          var radius = 10;
          var padding = 10;
          var textPadding = 15;

          function sector_size(d) {
            return (
                d.y0 - d.y1
              ) - padding;
          }

          // sector region
          sectorsEnter
          .append("rect")
          .attr("rx", radius)
          .attr("ry", radius)
          .attr("width", bar_w)
          .attr("x", function(d) {
            return - bar_w / 2;
          })
          .attr("y", function(d) {
            return padding / 2;
          })
          .attr("height", function(d, i, list) {
            return d.y0 - d.y1 - ((i === 0) ? 0 : padding);
          });

          // sector text label
          sectorsEnter
          .append('text')
          .append('tspan')
          .attr('width', function(d) {
            return d.y0 - d.y1 - textPadding;
          })
          .attr('class', 'label')
          .text(function(d) {
            return [format(d.value), format(d.lastValue)].join('-')
          })
          .each(function clip(d, i) {
            var text_size = this.getComputedTextLength();
            var width = $(this).attr('width');
            // text overflowed
            if(text_size > width) {
              // last value
              if (i === data.length - 1) {
                $(this).text([format(d.lastValue), '+'].join(' '));
              }
              // first value
              if (i === 0) {
                $(this).text(['<', format(d.value)].join(' '));
              }
            }
          })
          .each(ellipsis)
          .attr('y', function(d) {
            return ( d.y0 - d.y1 ) / 2;
          });

          sectors = sectors.merge(sectorsEnter);
        },
        _highlightSeries: function(id) {

          if(id) {
            // name axis
            d3.selectAll('.axis.axis-name text.label').each(function toggleActive(d) {
              $(this).classed('active', d.id === id);
            });
            var item = this.data.find(function(d) {
              return d.id === id;
            });
            // other axis
            this.dimensions.forEach(function(d) {
              highlightSector(d.name, item);
            })
          }

          function highlightSector(name, item) {
            d3.selectAll('.axis.axis-' + name + ' .sector').each(function toggleActive(d_sector) {
              var val = item[name];
              var b = val >= d_sector.lastValue && val <= d_sector.value;
//              console.log('sector match:', name, d_sector.lastValue, d_sector.value, val, b);
              $(this).classed('active', b);
            });
          }
        },
        _highlightSector: function(sector) {
          var name = sector.name;
          if(sector) {
            // name axis
            d3.selectAll('.axis.axis-name text.label').each(function toggleActive(d) {
              $(this).classed('active', valueInSector(d[name]));
            });
            d3.selectAll('.background path,.foreground path').each(function toggleActive(d) {
              $(this).classed('active', valueInSector(d[name]));
            });
          }

          function valueInSector(val) {
            return val >= sector.lastValue && val <= sector.value;
          }
        },
        _getDimensions: function(data, margin, height) {
          height = height - this.margin.top - this.margin.bottom;
          var definition = data[0];
          var currency = d3.format(",.2s");
          var dims = [
            {
              name: "name",
              scale: d3.scaleBand().range([0, height]).padding(.1),
              type: String
            },
            {
              name: "scan",
              scale: d3.scaleLinear().range([height, 0]),
              type: Number
            },
            {
              name: "exposure",
              scale: d3.scaleLinear().range([height, 0]),
              type: Number
            },
            {
              name: "usage",
              scale: d3.scaleLinear().range([height, 0]),
              type: Number
            },
            {
              name: "fix",
              scale: d3.scaleLinear().range([height, 0]),
              type: Number
            },
            {
              name: "stop",
              scale: d3.scaleLinear().range([height, 0]),
              type: Number
            },
            {
              name: "profit",
              scale: d3.scaleLinear().range([height, 0]),
              type: Number,
              format: function(val) {
                return currency(val/1e4);
              }
            }
          ];
          return dims.map(function(dimension) {
            var name = dimension.name;
            if (name === 'name') {
              dimension.label = definition['rating_text'];
              return dimension;
            }
            var label = definition[name + '_text'];
            var unit = definition[name + '_unit'];
            dimension.label = label + '(' + unit + ')';
            return dimension;
          });
        },
        _replot: function(width, height) {
          var key = this.queryUrl;
          this.$.svg.innerHTML = '';
          this.debounce('replot', this.render, 500);
        },
        ready: function() {
          this._loadData();
        },
        _loadData: function() {
          var _this = this;
          return fetch('mock/device-dimensions.json', {
            credentials: 'same-origin'
          }).then(function(res) {
            return res.json();
          }).then(function(data) {
            _this.set('data', data.items);
            _this.set('scales', data.ruler);
          });
        },
        _onResize: function() {
          var rect = this.$.chart.getBoundingClientRect();
          this.set('width', rect.width);
          this.set('height', rect.height);
        },
      });
    });
  </script>
</dom-module>