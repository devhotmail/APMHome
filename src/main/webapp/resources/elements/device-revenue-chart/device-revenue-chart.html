<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="device-revenue-chart-styles.html">
<script src="../../bower_components/d3-transform/src/d3-transform.js"></script>
<script src="../../bower_components/lscache/lscache.js"></script>
<script src="../../bower_components/urijs/src/URI.js"></script>

<dom-module id="device-revenue-chart">
  <template>
    <style include="device-revenue-chart-styles"></style>
    <div class="ui-g">
      <div class="ui-g-12">
        <div class="block">
          <div id="chart" class="chart-container">
            <svg id="chartSvg" width$="[[width]]" height$="[[height]]"></svg>
          </div>
        </div>
      </div>
    </div>
  </template>
  <script>
    (
      function() {
        function project(x, radius) {
          var angle = ( x - 180 ) / 180 * Math.PI;
          return [radius * Math.cos(angle), radius * Math.sin(angle)];
        }

        function gaugeDefaultConfig() {
          return {
            width: 100, // The gauge minimum value.
            height: 100, // The gauge minimum value.
            minValue: 0, // The gauge minimum value.
            maxValue: 100, // The gauge maximum value.
            circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.
            circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.
            circleColor: "#178BCA", // The color of the outer circle.
            waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.
            waveCount: 1, // The number of full waves per width of the wave circle.
            waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.
            waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.
            waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.
            waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.
            waveAnimate: true, // Controls if the wave scrolls or is static.
            waveColor: "#178BCA", // The color of the fill wave.
            waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.
            textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.
            textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%
            valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.
            textColor: "#045681", // The color of the value text when the wave does not overlap it.
            waveTextColor: "#fff" // The color of the value text when the wave overlaps it.
          };
        }

        function renderGauge(element, value, config) {
          if (config == null) {
            config = gaugeDefaultConfig();
          }
          var gauge = d3.select(element);
          var radius = Math.min(config.width, config.height) / 2;
          var locationX = -parseInt(config.width) / 2;
          var locationY = -parseInt(config.height) / 2;
          var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;
          var waveHeightScale;
          if (config.waveHeightScaling) {
            waveHeightScale = d3.scaleLinear()
            .range([0, config.waveHeight, 0])
            .domain([0, 50, 100]);
          } else {
            waveHeightScale = d3.scaleLinear()
            .range([config.waveHeight, config.waveHeight])
            .domain([0, 100]);
          }
          var textPixels = (
            config.textSize * radius / 2
          );
          var textFinalValue = parseFloat(value).toFixed(2);
          var textStartValue = config.valueCountUp ? config.minValue : textFinalValue;
          var circleThickness = config.circleThickness * radius;
          var circleFillGap = config.circleFillGap * radius;
          var fillCircleMargin = circleThickness + circleFillGap;
          var fillCircleRadius = radius - fillCircleMargin;
          var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);
          var waveLength = fillCircleRadius * 2 / config.waveCount;
          var waveClipCount = 1 + config.waveCount;
          var waveClipWidth = waveLength * waveClipCount;
          var data = config.node.data;
          var labelUnit = data.label_unit;

          // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
          var textFormat = function(value) { return Math.round(value) + labelUnit; };
          if (parseFloat(textFinalValue) != parseFloat(textFormat(textFinalValue))) {
            textFormat = function(value) { return parseFloat(value).toFixed(1); };
          }
          if (parseFloat(textFinalValue) != parseFloat(textFormat(textFinalValue))) {
            textFormat = function(value) { return parseFloat(value).toFixed(2); };
          }

          // Data for building the clip wave area.
          var data = [];
          for (var i = 0; i <= 40 * waveClipCount; i++) {
            data.push({
              x: i / (
                40 * waveClipCount
              ),
              y: (
                i / (
                  40
                )
              )
            });
          }
          // Scales for drawing the outer circle.
          var gaugeCircleX = d3.scaleLinear().range([0, 2 * Math.PI]).domain([0, 1]);
          var gaugeCircleY = d3.scaleLinear().range([0, radius]).domain([0, radius]);
          // Scales for controlling the size of the clipping path.
          var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);
          var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);
          // Scales for controlling the position of the clipping path.
          var waveRiseScale = d3.scaleLinear()
          // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
          // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
          // circle at 100%.
          .range([fillCircleMargin + fillCircleRadius * 2 + waveHeight, fillCircleMargin-waveHeight])
          .domain([0, 1]);
          var waveAnimateScale = d3.scaleLinear()
          .range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.
          .domain([0, 1]);

          // Scale for controlling the position of the text within the gauge.
          var textRiseScaleY = d3.scaleLinear()
          .range([fillCircleMargin + fillCircleRadius*2, fillCircleMargin + (fillCircleRadius * 2* (1-fillPercent)) + textPixels * 0.7])
          .domain([0, 1]);

          // Center the gauge within the parent SVG.
          var gaugeGroup = gauge.append("g")
          .attr('class', 'gauge')
          .attr('transform', 'translate(' + locationX + ',' + locationY + ')');
          gaugeGroup.append("circle")
          .attr("r", gaugeCircleY(radius))
          .style("fill", '#fff')
          .style("stroke", config.circleColor)
          .style("stroke-width", gaugeCircleY(circleThickness))
          .attr('transform', 'translate(' + radius + ',' + radius + ')');
          
          // Text to show current node's name
          // at least depth over 0
          if (config.showLabel) {
            var node = config.node;
            var distance = 30;
            var r = gaugeCircleY(radius);
            var _radius = r + distance;

            // position according to center of the circle
            var absolutePos = project(node.x, node.y);
            var x0 = Math.abs(absolutePos[0]);
            var y0 = Math.abs(absolutePos[1]);

            // distance tree root center of the circle
            // the line between these two pointers is vertical
            var root2Center = Math.sin(START_ANGEL * Math.PI/180) * node.y;

            // position according to tree root node
            var x = x0;
            var y = Math.abs(y0 - root2Center);

            var distance2Parent = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));

            var x0 = x / distance2Parent * _radius;
            var y0 = y / distance2Parent * _radius;

            var pos = [x0, y0];
            if (absolutePos[0] === 0) pos = [0, y0];
            if (absolutePos[0] > 0) pos = [-x0, y0];
            
            // draw text to this group
            gauge.append('g')
            .attr('transform', function() {
              return 'translate(' + pos.join(',') + ')';
            })
            .append('text')
            .attr('class', 'link-label')
            .attr('text-anchor', 'middle')
            .attr('fill', config.waveColor)
            .text(node.data.name);
          }

          // Text where the wave does not overlap.
          var text1 = gaugeGroup.append("text")
          .text(textFormat(textStartValue))
          .attr("class", "liquidFillGaugeText")
          .attr("text-anchor", "middle")
          .attr("font-size", textPixels + "px")
          .style("fill", config.textColor)
          .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');
          // The clipping wave area.
          var clipArea = d3.area()
          .x(function(d) { return waveScaleX(d.x); })
          .y0(function(d) {
            return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (
                1 - config.waveCount
              ) + d.y * 2 * Math.PI));
          })
          .y1(function(d) {
            return (
              fillCircleRadius * 2 + waveHeight
            );
          });
          var clip_wave_id = gauge.attr('id');
          var waveGroup = gaugeGroup.append("defs")
          .append("clipPath")
          .attr("id", "clipWave" + clip_wave_id);
          var wave = waveGroup.append("path")
          .datum(data)
          .attr("d", clipArea)
          .attr("T", 0);
          // The inner circle with the clipping wave attached.
          var fillCircleGroup = gaugeGroup.append("g")
          .attr("clip-path", "url(#clipWave" + clip_wave_id + ")");
          fillCircleGroup.append("circle")
          .attr("cx", radius)
          .attr("cy", radius)
          .attr("r", fillCircleRadius)
          .style("fill", config.waveColor);

          // Text where the wave does overlap.
          var text2 = fillCircleGroup.append("text")
          .text(textFormat(textStartValue))
          .attr("class", "liquidFillGaugeText")
          .attr("text-anchor", "middle")
          .attr("font-size", textPixels + "px")
          .style("fill", config.waveTextColor)
          .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');
          // Make the value count up.
          if (config.valueCountUp) {
            var textTween = function() {
              var textStartValue = this.textContent.match(/\d+/)[0];
              var node = this;
              var i = d3.interpolate(parseInt(textStartValue), parseInt(textFinalValue));
              return function(t) {
                node.textContent = textFormat(i(t));
              }
            };

            text1.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);

            text2.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);
          }
          // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
          var waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;
          if (config.waveRise) {
            waveGroup
            .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')
            .transition()
            .duration(config.waveRiseTime)
            .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
            // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
            .on("start", function() { wave.attr('transform', 'translate(1,0)'); });
          } else {
            waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');
          }
          if (config.waveAnimate) animateWave();
          function animateWave() {
            wave.attr('transform', 'translate(' + waveAnimateScale(wave.attr('T')) + ',0)');
            wave.transition()
            .duration(config.waveAnimateTime * (
                1 - wave.attr('T')
              ))
            .ease(d3.easeLinear)
            .attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')
            .attr('T', 1)
            .on('end', function() {
              wave.attr('T', 0);
              animateWave(config.waveAnimateTime);
            });
          }

          function GaugeUpdater() {
            this.update = function(value) {
              var newFinalValue = parseFloat(value).toFixed(2);
              var textRounderUpdater = function(value) { return Math.round(value); };
              if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
                textRounderUpdater = function(value) { return parseFloat(value).toFixed(1); };
              }
              if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
                textRounderUpdater = function(value) { return parseFloat(value).toFixed(2); };
              }
              var textTween = function() {
                var i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));
                return function(t) {
                  this.textContent = textRounderUpdater(i(t));
                }
              };
              text1.transition()
              .duration(config.waveRiseTime)
              .tween("text", textTween);
              text2.transition()
              .duration(config.waveRiseTime)
              .tween("text", textTween);
              var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;
              var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);
              var waveRiseScale = d3.scaleLinear()
              // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
              // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
              // circle at 100%.
              .range([
                (
                  fillCircleMargin + fillCircleRadius * 2 + waveHeight
                ),
                (
                  fillCircleMargin - waveHeight
                )
              ])
              .domain([0, 1]);
              var newHeight = waveRiseScale(fillPercent);
              var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);
              var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);
              var newClipArea;
              if (config.waveHeightScaling) {
                newClipArea = d3.area()
                .x(function(d) { return waveScaleX(d.x); })
                .y0(function(d) {
                  return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (
                      1 - config.waveCount
                    ) + d.y * 2 * Math.PI));
                })
                .y1(function(d) {
                  return (
                    fillCircleRadius * 2 + waveHeight
                  );
                });
              } else {
                newClipArea = clipArea;
              }
              var newWavePosition = config.waveAnimate ? waveAnimateScale(1) : 0;
              wave.transition()
              .duration(0)
              .transition()
              .duration(config.waveAnimate ?
                        (
                          config.waveAnimateTime * (
                            1 - wave.attr('T')
                          )
                        ) :
                        (
                          config.waveRiseTime
                        ))
              .ease(d3.easeLinear)
              .attr('d', newClipArea)
              .attr('transform', 'translate(' + newWavePosition + ',0)')
              .attr('T', '1')
              .each("end", function() {
                if (config.waveAnimate) {
                  wave.attr('transform', 'translate(' + waveAnimateScale(0) + ',0)');
                  animateWave(config.waveAnimateTime);
                }
              });
              waveGroup.transition()
              .duration(config.waveRiseTime)
              .attr('transform', 'translate(' + waveGroupXPosition + ',' + newHeight + ')')
            }
          }

          return new GaugeUpdater();
        }

        function nodeRadius(node) {
          var data = node.data;
          var parent = node.parent;
          if(parent){
            return gauge_size(data.revenue / parent.data.revenue);
          }
          return ROOT_RADIUS;
        }

        // how much degree of the arc is off screen
        var START_ANGEL = 45;
        var PAGER_BORDER_COLOR = 'rgba(177,177,188, 1)';
        var PAGER_START_ANGEL = START_ANGEL - 3;
        // how much degree to separate adjacent orbit items
        var MARGIN_ANGEL = 1;
        // total revenue size
        var ROOT_RADIUS = 80;
        // transition duration
        var DURATION = 750;
        // page transition duration
        var DURATION_PAGING = 1000;
        var PAGER_RADIUS = 30;
        // id counter seed
        var i = 0;
        var gauge_size = d3.interpolate(20, 80);
        var gauge_color = d3.scaleOrdinal([
          'rgba(117, 162, 234, 1)',
          'rgba(140, 211, 199, 1)',
          'rgba(204, 185, 92, 1)',
          'rgba(187, 128, 188, 1)',
          'rgba(128, 177, 211, 1)',
          'rgba(184, 188, 128, 1)',
          'rgba(157, 155, 191, 1)',
          'rgba(152, 186, 145, 1)'
        ]);

        function renderNode(node, i) {
          var config = gaugeDefaultConfig();
          var data = node.data;
          config.height = config.width = node.size * 2;
          config.circleColor = config.waveColor = gauge_color(i);
          config.waveAnimateTime = 5000;
          config.waveHeight = 0.15;
          config.waveOffset = 0.25;
          config.maxValue = data.revenue;
          config.node = node;
          config.isRoot = node.depth;
          config.showLabel = node.depth === 1; // only show label for depth one

          renderGauge(this, data.profit, config);
        }

        function layout_orbit(root, options) {
          var nodes = root.children;
          var margin = options.margin;
          var maxR = options.canvasRadius;
          var startDeg = options.start || 0;
          var endDeg = options.end || 180;
          var deg = startDeg;
          var lastDeg = 0;
          var thisDeg = 0;
          var max = 0;
          var radiusScale = d3.scaleLinear().domain([maxR, 0]).range([1, 0]);

          // item radius v.s. orbit radius
          var r, R = options.radius, degEach, scale = radiusScale(R);
          for (var i = 0, node, lastNode, length = nodes.length; node = nodes[i], i < length; i++) {
            r = nodeRadius(node) * scale;
            thisDeg = Math.atan(r / R) * (
              180 / Math.PI
              );

            node.x = deg + thisDeg + margin;
            node.y = R;
            node.size = r;
            node.scale = scale;

            // degree increments
            deg += ( thisDeg + margin ) * 2;

            if (deg < endDeg) {
              max++;
            } else {
              break;
            }
          }
          // layout the root
          root.x = 90;
          root.y = Math.sin(START_ANGEL * Math.PI / 180) * R - 100;
          root.size = ROOT_RADIUS;
          root.children = root.children.slice(0, max);

          return {
            count: max,
            deg: deg - startDeg
          };
        }

        // https://github.com/d3/d3-shape/issues/27
        // replacement for diagonal
        function linkStraight(source, target) {
          return 'M' + project(source.x, source.y) + 'L' + project(target.x, target.y);
        }

        function linkVertical(source, target) {
          return 'M' + source.x + ',' + source.y
            + 'C' + (source.x + target.x) / 2 + ',' + source.y
            + ' ' + (source.x + target.x) / 2 + ',' + target.y
            + ' ' + target.x + ',' + target.y
        }

        function formatConvert(data){
          return Object.assign({}, data, {
            revenue: parseFloat(data.revenue_label),
            profit: parseFloat(data.profit_label)
          });
        }

        function parseTransformRotate(element) {
          var rotate;
          var match = element.getAttribute('transform').match(/rotate\(([^)]+)\)/);
          if (match) {
            rotate = match[1].split(',');
            return {
              deg: rotate[0],
              x: +rotate[1],
              y: +rotate[2]
            };
          }
          return null;
        }

        function rotateToTween(dest) {
          return function transform() {
            var rotate = parseTransformRotate(this);
            var interpolate = d3.interpolateNumber(rotate.deg, dest);
            return function(t) {
              var deg = interpolate(t);
              return d3Transform().rotate(deg, rotate.x, rotate.y)();
            };
          }
        }

        function rotate(dest){
          return function() {
            var rotate = parseTransformRotate(this);
            return d3Transform().rotate(dest, rotate.x, rotate.y)();
          }
        }

        function pageEntered(page) {
          var _this = this;
          return function() {
            // remove opacity inline styles
            var $el = d3.select(this).style('opacity', '');
            $el.attr('class', page + '-page');
            // reconcile dom
            _this.scopeSubtree(this);
          }
        }

        Polymer({
          is: 'device-revenue-chart',
          properties: {
            data: {
              type: Object,
              observer: 'replot'
            },
            _pageStartHistoryL1: {
              type: Array,
              value: []
            },
            pageLastStartL1: {
              type: Number
            },
            pageStartL1: {
              type: Number,
              value: 0,
              observer: '_pageChanged'
            },
            pageOffsetL1: {
              type: Number,
              value: 0
            },
            pageEndL1: {
              type: Number,
              value: 0
            },
            width: Number,
            height: Number
          },
          observers: [
            '_computeLastStart(_pageStartHistoryL1.*)'
          ],
          plotRoot: function(root) {
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              offsetX = width / 2,
              offsetY = height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200;

            var node = {
              data: root,
              x: 90,
              y: Math.sin(START_ANGEL * Math.PI / 180) * radius - 100,
              size: ROOT_RADIUS,
              parent: null
            };

            var canvas = svg.append("g")
            .attr('transform', d3Transform().rotate(0, width / 2, offsetY))
            .attr("transform", "translate(" + offsetX + "," + offsetY + ")");

            // Update the nodes
            canvas.selectAll('g.node')
            .data([node]).enter().append("g")
            .attr("transform", function(d) {
              return "translate(" + project(d.x, d.y) + ")";
            })
            .each(renderNode);
          },
          plotPager: function(url) {
            var _this = this;
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              offsetX = width / 2,
              offsetY = height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200;

            var nodes = [
              {
                type: 'prev',
                x: PAGER_START_ANGEL,
                y: radius,
              },
              {
                type: 'next',
                x: 180 - PAGER_START_ANGEL,
                y: radius,
              }
            ];
            var canvas = svg.append("g").attr('class', 'pagination')
            .attr('transform', d3Transform().rotate(0, width / 2, offsetY))
            .attr("transform", "translate(" + offsetX + "," + offsetY + ")");

            // Update the nodes
            canvas.selectAll('g.node')
            .data(nodes).enter().append("g")
            .attr("transform", function(d) {
              return "translate(" + project(d.x, d.y) + ")";
            })
            .each(function(d) {
              var node = d3.select(this).append("g");

              node.append("circle")
              .attr("cx", PAGER_RADIUS / 2)
              .attr("cy", PAGER_RADIUS / 2)
              .attr("r", PAGER_RADIUS)
              .style("fill", 'transparent')
              .style("stroke", PAGER_BORDER_COLOR)
              .style("stroke-width", "2px")
              .on('click', function handlePagerClick() {
                var type = d.type;
                type === 'next' ? _this.openNextPage(url) : _this.openPrevPage(url);
              });

              node.append('path')
              .attr('d', d3.symbol().type(d3.symbolTriangle).size(300))
              .attr('transform',
                d3Transform()
                .translate(PAGER_RADIUS / 2, PAGER_RADIUS / 2)
                .rotate(180))
              .style('fill', PAGER_BORDER_COLOR);
            });
          },
          replot: function(root, children) {
            var data = Object.assign({children: children}, root);
            var _this = this;
            var _opening = null;
            var tree = d3.hierarchy(data);

            // layout start
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              offsetX = width / 2,
              offsetY = height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200;

            var canvas = svg.insert('g', ':first-child').attr('transform', d3Transform().rotate(0, width / 2, offsetY));
            var rootGroup = canvas.append("g");
            rootGroup.attr("transform", "translate(" + offsetX+ "," + offsetY + ")");
            var result = layout_orbit(tree, {
              start: START_ANGEL,
              end: 180 - START_ANGEL,
              radius: radius,
              canvasRadius: width / 2,
              margin: MARGIN_ANGEL
            });

            var nodes = tree.descendants();
            var links = tree.links();

            var link = rootGroup.selectAll('.link')
            .data(nodes.slice(1), function(d) {
              return d.data.id;
            });

            // Enter any new links at the parent's previous position.
            var linkEnter = link.enter().append('path')
            .attr('class', 'link')
            .attr('d', function(d) {
              var source = d.parent;
              return linkStraight(source, source);
            });

            var linkUpdate = link.merge(linkEnter)
            .transition()
            .duration(DURATION)
            .attr('d', function(d) {
              var source = d;
              var target = d.parent;
              return linkStraight(source, target);
            });

            // Update the nodes
            var node = rootGroup.selectAll('g.node')
            .data(nodes.slice(1), function(d) {
              return d.data.id || (d.data.id = ++i)
            });

            var nodeEnter = node.enter().append("g")
            .attr("class", function(d) {
              return "node" + (
                  d.children ? " node--internal" : " node--leaf"
                );
            })
            .attr("transform", function(d) {
              var _node = d.parent ? d.parent : d;
              return "translate(" + project(_node.x, _node.y) + ")";
            })
            .attr('id', function(d) {
              return 'node-' + d.data.id;
            })
            .on('click', handleClick)
            .each(renderNode);

            // Transition nodes to their new position.
            var nodeUpdate = node.merge(nodeEnter)
            .transition()
            .duration(DURATION)
            .attr('transform', function(d) {
              return 'translate(' + project(d.x, d.y) + ')';
            });

            // Mark previous position down
            nodes.forEach(function(d) {
              d.x0 = d.x;
              d.y0 = d.y;
            });

            this.scopeSubtree(this.$.chart, true);

            return Object.assign(result, {
              element: canvas
            });

            function resetOrbit1() {
              // reset to render subtree
              node.merge(nodeUpdate)
              .data(tree.descendants())
              .transition()
              .duration(DURATION)
              .attr('transform', function(d) {
                if (d.parent) {
                  // recover to original position
                  return 'translate(' + project(d.x0, d.y0) + ')';
                } else {
                  // dont move the position of tree root
                  return 'translate(' + project(d.x0, d.y0) + ')';
                }
              })
              .each(function(d, i, nodeList) {
                // reset the gauge size and position
                if (d.parent) {
                  d3.select(nodeList[i])
                  .select('g.gauge')
                  .transition()
                  .duration(DURATION)
                  .attr('transform', function(d) {
                    var pos = [d.size, d.size].map(function(n) {
                      return -n;
                    });
                    return 'translate(' + pos.join(',') + ')';
                  });
                }
              });

              link.merge(linkUpdate)
              .data(tree.descendants().slice(1))
              .transition()
              .duration(DURATION)
              .attr('d', function(d) {
                var source = {
                  x: d.x0,
                  y: d.y0
                };
                var target = {
                  x: d.parent.x0,
                  y: d.parent.y0
                };
                return linkStraight(source, target);
              });
            }

            function handleClick(targetNode) {
              if (targetNode.parent) {
                // build a new smaller tree layout
                var new_radius = radius - 200;
                layout_orbit(tree, {
                  start: START_ANGEL,
                  end: 180 - START_ANGEL,
                  radius: new_radius,
                  canvasRadius: width / 2,
                  margin: MARGIN_ANGEL
                });
                // rerender subtree's children
                node.merge(nodeUpdate)
                .data(tree.descendants())
                .transition()
                .duration(DURATION)
                .attr('transform', function(d) {
                  if (d.depth === 1) {
                    return 'translate(' + project(d.x, d.y) + ')';
                  }
                  if (d.depth === 0) {
                    // dont move the position of tree root
                    return 'translate(' + project(d.x0, d.y0) + ')';
                  }
                })
                .on('end', function(d) {
                  // when this opening node is in position.
                  if(d.data.id === targetNode.data.id){
                    _opening = openNode(targetNode);
                  }
                })
                .each(function(d, i, nodeList) {
                  // make the gauge smaller
                  if (d.parent) {
                    d3.select(nodeList[i])
                    .select('g.gauge')
                    .transition()
                    .duration(DURATION)
                    .attr('transform', function(d) {
                      var pos = [d.size, d.size].map(function(n) {
                        return -n * d.scale;
                      });
                      return 'translate(' + pos.join(',') + ')' + ' scale(' + d.scale + ')';
                    });
                  }
                });

                link.merge(linkUpdate)
                .data(tree.descendants().slice(1))
                .transition()
                .duration(DURATION)
                .attr('d', function(d) {
                  var source = d;
                  var target = {
                    x: d.parent.x0,
                    y: d.parent.y0
                  };
                  return linkStraight(source, target);
                });
              } else {

                // check if there's a 2nd orbit now
                if (_opening) {
                  _opening.then(function(closeNode) {
                    closeNode().then(resetOrbit1);
                  })
                } else {
                  resetOrbit1();
                }
              }
            }

            function openNode(node) {
              // check node already opened
              if(_this.$.chartSvg.querySelector('#tree--' + node.data.id)) {
                return Promise.resolve(false);
              }

              return _this.handleRequestNode(node).then(function layoutOrbit2(data) {
                var subTree = d3.hierarchy(data);
                subTree.data = node.parent.data;
                svg.select('.orbit2').remove();

                var subGroup =
                  svg.insert("g", ':first-child')
                  .attr('class', 'orbit2')
                  .attr('id', 'tree--'+node.data.id)
                  .attr("transform",
                  "translate(" + (
                    width / 2
                  ) + "," + (
                    height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200
                  ) + ")"
                );

                // calc start angle
                var arcDeg = layout_orbit(subTree, {
                  start: START_ANGEL,
                  end: 180 - START_ANGEL,
                  radius: radius,
                  canvasRadius: width / 2,
                  margin: MARGIN_ANGEL / 2
                }).deg;

                var startDeg;
                var parentDeg = node.x - START_ANGEL;
                var totalDeg = 180 - START_ANGEL * 2;
                if (arcDeg / 2 < parentDeg) {
                  startDeg = parentDeg - arcDeg/2;
                } else if(arcDeg / 2 > parentDeg) {
                  startDeg = 0;
                }
                startDeg += START_ANGEL;

                // calc start angle
                var arcDeg = layout_orbit(subTree, {
                  start: startDeg,
                  end: 180 - START_ANGEL,
                  radius: radius,
                  canvasRadius: width / 2,
                  margin: MARGIN_ANGEL / 2
                }).deg;

                var nodes = subTree.descendants().slice(1);
                var links = subTree.links();
                var link = subGroup.selectAll('.link')
                .data(nodes, function(d) {
                  return d.data.id;
                });

                // Enter any new links at the parent's previous position.
                var linkEnter = link.enter().append('path')
                .attr('class', 'link')
                .attr('d', function(d) {
                  return linkStraight(node, node);
                });

                var linkUpdate = link.merge(linkEnter)
                .transition()
                .duration(DURATION/2)
                .attr('d', function(d) {
                  return linkStraight(node, d);
                });

                var groups = subGroup.selectAll('g.node')
                .data(nodes, function(d) {
                  return d.data.id || (
                      d.data.id = ++i
                    )
                });

                var nodeEnter = groups.enter().append("g")
                .attr("class", function(d) {
                  return "node" + (
                      d.children ? " node--internal" : " node--leaf"
                    );
                })
                .attr("transform", function(d) {
                  return "translate(" + project(node.x, node.y) + ")";
                })
                .attr('id', function(d) {
                  return 'node-' + d.data.id;
                })
                .each(renderNode);

                // Transition nodes to their new position.
                var nodeUpdate = groups.merge(nodeEnter)
                .transition()
                .duration(DURATION/2)
                .attr('transform', function(d) {
                  return 'translate(' + project(d.x, d.y) + ')';
                });

                return function closeNode() {
                  return new Promise(function(resolve, reject) {
                    // reset to render subtree
                    groups.merge(nodeUpdate)
                    .data(subTree.descendants())
                    .transition()
                    .duration(DURATION / 2)
                    .attr('transform', function(d) {
                      // recover to original position
                      return 'translate(' + project(node.x, node.y) + ')';
                    })
                    .on('end', function(d, i) {
                      // when orbit 2 is closed
                      if (i === 0) {
                        subGroup.remove();
                        resolve();
                      }
                    })

                    link.merge(linkUpdate)
                    .data(subTree.descendants())
                    .transition()
                    .duration(DURATION / 2)
                    .attr('d', function(d) {
                      return linkStraight(node, node);
                    });
                  });
                }
              });
            }
          },
          handleRequestNode: function(node) {
            var nodeId = node.data.id;
            if(nodeId > 3){
              nodeId = 2;
            }
            return fetch('mock/revenue-data-' + nodeId + '.json').then(function(res) {
              return  res.json();
            });
          },
          nextPage: function() {
            var offset = this.get('pagination.0.offset');
            var count = this.get('pagination.0.count');
            this.set('pagination.0.offset', offset + count);
          },
          _computeLastStart: function() {
            var history = this._pageStartHistoryL1;
            this.pageLastStartL1 = history[history.length - 1];
          },
          _pageChanged: function(newVal, oldVal) {
            // on page changed build the offset history, in order to navigate backwards.
            if (oldVal === undefined || newVal > oldVal) {
              this.push('_pageStartHistoryL1', oldVal);
            } else {
              this.pop('_pageStartHistoryL1');
            }
          },
          // Load next "n" more items from the URL and add them to cache
          loadData: function(url, n) {
            var _this = this;
            n = n || 20;
            var cacheKey = url;
            var list = lscache.get(cacheKey) || [];
            var length = list.length || 0;
            // read the furthest offset
            var offset = this.pageEndL1;
            if (length - offset < n) {
              url = URI(url).addQuery({
                'start': length,
                'limit': n
              }).toString();
              return fetch(url).then(function(res) {
                return res.json();
              }).then(function(data) {
                list = list.concat(data.items.map(formatConvert));
                lscache.set(cacheKey, list);
                lscache.set(cacheKey+'/root', formatConvert(data.root));
              });
            } {
              return Promise.resolve();
            }
          },
          renderCurrPage: function(key) {
            var start = this.pageStartL1;
            var list = lscache.get(key) || [];
            list = list.slice(start);
            var root = lscache.get(key + '/root');
            var result = this.replot(root, list);
            this.plotRoot(root);
            this.plotPager(key);
            result.element.attr('class', 'curr-page');
            this.pageOffsetL1 = result.count;
            this.renderNextPage(key);
            this.renderPrevPage(key);
          },
          renderNextPage: function(key) {
            var start = this.pageOffsetL1;
            var list = lscache.get(key) || [];
            if (list.length > start) {
              list = list.slice(start);
              var result = this.replot(lscache.get(key + '/root'), list);
              result.element.attr('class', 'next-page').attr('transform', rotate(90));
              this.pageEndL1 = start + result.count;
            }
          },
          renderPrevPage: function(key) {
            var start = this.pageLastStartL1, end = this.pageStartL1;
            var list = lscache.get(key) || [];
            var result;
            if (!isNaN(start)) {
              list = list.slice(start, end);
              result = this.replot(lscache.get(key + '/root'), list);
              result.element.attr('class', 'prev-page').attr('transform', rotate(-90));
            }
          },
          openNextPage: function(key) {
            // move page offset counter-clockwise
            this.pageStartL1 = this.pageOffsetL1;
            this.pageOffsetL1 = this.pageEndL1;
            delete this.pageEndL1;

            // load next page
            this.renderNextPage(key);

            d3.select('.next-page')
            .transition()
            .duration(DURATION_PAGING)
            .style('opacity', 1)
            .attrTween('transform', rotateToTween(0)).on('end', pageEntered.call(this, 'curr'));

            d3.select('.curr-page')
            .transition()
            .style('opacity', 0)
            .duration(DURATION_PAGING)
            .attrTween('transform', rotateToTween(-90)).on('end', pageEntered.call(this, 'prev'))
          },
          openPrevPage: function(key) {
            // move page offset clockwise
            this.pageEndL1 = this.pageOffsetL1;
            this.pageOffsetL1 = this.pageStartL1;
            this.pageStartL1 = this.pageLastStartL1;

            // load prev page
            this.renderPrevPage(key);

            d3.select('.prev-page')
            .transition()
            .duration(DURATION_PAGING)
            .style('opacity', 1)
            .attrTween('transform', rotateToTween(0))
            .on('end', pageEntered.call(this, 'curr'));

            d3.select('.curr-page')
            .transition()
            .style('opacity', 0)
            .duration(DURATION_PAGING)
            .attrTween('transform', rotateToTween(90)).on('end', pageEntered.call(this, 'next'));

            // kick out next
            d3.select('.next-page').remove();
          },
          ready: function() {
            var _this = this;
            var rect = this.$.chart.getBoundingClientRect();
            this.set('width', rect.width);
            this.set('height', rect.height);
            var url = 'mock/profit-2016-by-type.json';
            this.loadData(url).then(function() {
              _this.renderCurrPage(url);
            });
          }
        });
      }
    )();
  </script>
</dom-module>