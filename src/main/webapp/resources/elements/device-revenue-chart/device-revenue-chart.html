<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="device-revenue-chart-styles.html">

<dom-module id="device-revenue-chart">
  <template>
    <style include="device-revenue-chart-styles"></style>
    <div id="chart" class="chart-container">
      <svg id="chartSvg" width$="[[width]]" height$="[[height]]"></svg>
    </div>
  </template>
  <script>
    (
      function() {
        function project(x, radius) {
          var angle = ( x - 180 ) / 180 * Math.PI;
          return [radius * Math.cos(angle), radius * Math.sin(angle)];
        }

        function gaugeDefaultConfig() {
          return {
            width: 100, // The gauge minimum value.
            height: 100, // The gauge minimum value.
            minValue: 0, // The gauge minimum value.
            maxValue: 100, // The gauge maximum value.
            circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.
            circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.
            circleColor: "#178BCA", // The color of the outer circle.
            waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.
            waveCount: 1, // The number of full waves per width of the wave circle.
            waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.
            waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.
            waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.
            waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.
            waveAnimate: true, // Controls if the wave scrolls or is static.
            waveColor: "#178BCA", // The color of the fill wave.
            waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.
            textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.
            textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%
            valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.
            textColor: "#045681", // The color of the value text when the wave does not overlap it.
            waveTextColor: "#fff" // The color of the value text when the wave overlaps it.
          };
        }

        function renderGauge(element, value, config) {
          if (config == null) {
            config = gaugeDefaultConfig();
          }
          var gauge = d3.select(element);
          var radius = Math.min(config.width, config.height) / 2;
          var locationX = -parseInt(config.width) / 2;
          var locationY = -parseInt(config.height) / 2;
          var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;
          var waveHeightScale;
          if (config.waveHeightScaling) {
            waveHeightScale = d3.scaleLinear()
            .range([0, config.waveHeight, 0])
            .domain([0, 50, 100]);
          } else {
            waveHeightScale = d3.scaleLinear()
            .range([config.waveHeight, config.waveHeight])
            .domain([0, 100]);
          }
          var textPixels = (
            config.textSize * radius / 2
          );
          var textFinalValue = parseFloat(value).toFixed(2);
          var textStartValue = config.valueCountUp ? config.minValue : textFinalValue;
          var circleThickness = config.circleThickness * radius;
          var circleFillGap = config.circleFillGap * radius;
          var fillCircleMargin = circleThickness + circleFillGap;
          var fillCircleRadius = radius - fillCircleMargin;
          var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);
          var waveLength = fillCircleRadius * 2 / config.waveCount;
          var waveClipCount = 1 + config.waveCount;
          var waveClipWidth = waveLength * waveClipCount;

          // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
          var textFormat = function(value) { return Math.round(value) + 'ä¸‡'; };
          if (parseFloat(textFinalValue) != parseFloat(textFormat(textFinalValue))) {
            textFormat = function(value) { return parseFloat(value).toFixed(1); };
          }
          if (parseFloat(textFinalValue) != parseFloat(textFormat(textFinalValue))) {
            textFormat = function(value) { return parseFloat(value).toFixed(2); };
          }

          // Data for building the clip wave area.
          var data = [];
          for (var i = 0; i <= 40 * waveClipCount; i++) {
            data.push({
              x: i / (
                40 * waveClipCount
              ),
              y: (
                i / (
                  40
                )
              )
            });
          }
          // Scales for drawing the outer circle.
          var gaugeCircleX = d3.scaleLinear().range([0, 2 * Math.PI]).domain([0, 1]);
          var gaugeCircleY = d3.scaleLinear().range([0, radius]).domain([0, radius]);
          // Scales for controlling the size of the clipping path.
          var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);
          var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);
          // Scales for controlling the position of the clipping path.
          var waveRiseScale = d3.scaleLinear()
          // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
          // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
          // circle at 100%.
          .range([fillCircleMargin + fillCircleRadius * 2 + waveHeight, fillCircleMargin-waveHeight])
          .domain([0, 1]);
          var waveAnimateScale = d3.scaleLinear()
          .range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.
          .domain([0, 1]);

          // Scale for controlling the position of the text within the gauge.
          var textRiseScaleY = d3.scaleLinear()
          .range([fillCircleMargin + fillCircleRadius*2, fillCircleMargin + (fillCircleRadius * 2* (1-fillPercent)) + textPixels * 0.7])
          .domain([0, 1]);

          // Center the gauge within the parent SVG.
          var gaugeGroup = gauge.append("g")
          .attr('class', 'gauge')
          .attr('transform', 'translate(' + locationX + ',' + locationY + ')');
          gaugeGroup.append("circle")
          .attr("r", gaugeCircleY(radius))
          .style("fill", '#fff')
          .style("stroke", config.circleColor)
          .style("stroke-width", gaugeCircleY(circleThickness))
          .attr('transform', 'translate(' + radius + ',' + radius + ')');
          
          // Text to show current node's name
          // at least depth over 0
          if (config.showLabel) {
            var node = config.node;
            var distance = 30;
            var r = gaugeCircleY(radius);
            var _radius = r + distance;

            // position according to center of the circle
            var absolutePos = project(node.x, node.y);
            var x0 = Math.abs(absolutePos[0]);
            var y0 = Math.abs(absolutePos[1]);

            // distance tree root center of the circle
            // the line between these two pointers is vertical
            var root2Center = Math.sin(START_ANGEL * Math.PI/180) * node.y;

            // position according to tree root node
            var x = x0;
            var y = Math.abs(y0 - root2Center);

            var distance2Parent = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));

            var x0 = x / distance2Parent * _radius;
            var y0 = y / distance2Parent * _radius;

            var pos = [x0, y0];
            if (absolutePos[0] === 0) pos = [0, y0];
            if (absolutePos[0] > 0) pos = [-x0, y0];
            
            // draw text to this group
            gauge.append('g')
            .attr('transform', function() {
              return 'translate(' + pos.join(',') + ')';
            })
            .append('text')
            .attr('text-anchor', 'middle')
            .attr('fill', config.waveColor)
            .text(node.data.name);
          }

          // Text where the wave does not overlap.
          var text1 = gaugeGroup.append("text")
          .text(textFormat(textStartValue))
          .attr("class", "liquidFillGaugeText")
          .attr("text-anchor", "middle")
          .attr("font-size", textPixels + "px")
          .style("fill", config.textColor)
          .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');
          // The clipping wave area.
          var clipArea = d3.area()
          .x(function(d) { return waveScaleX(d.x); })
          .y0(function(d) {
            return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (
                1 - config.waveCount
              ) + d.y * 2 * Math.PI));
          })
          .y1(function(d) {
            return (
              fillCircleRadius * 2 + waveHeight
            );
          });
          var clip_wave_id = gauge.attr('id');
          var waveGroup = gaugeGroup.append("defs")
          .append("clipPath")
          .attr("id", "clipWave" + clip_wave_id);
          var wave = waveGroup.append("path")
          .datum(data)
          .attr("d", clipArea)
          .attr("T", 0);
          // The inner circle with the clipping wave attached.
          var fillCircleGroup = gaugeGroup.append("g")
          .attr("clip-path", "url(#clipWave" + clip_wave_id + ")");
          fillCircleGroup.append("circle")
          .attr("cx", radius)
          .attr("cy", radius)
          .attr("r", fillCircleRadius)
          .style("fill", config.waveColor);

          // Text where the wave does overlap.
          var text2 = fillCircleGroup.append("text")
          .text(textFormat(textStartValue))
          .attr("class", "liquidFillGaugeText")
          .attr("text-anchor", "middle")
          .attr("font-size", textPixels + "px")
          .style("fill", config.waveTextColor)
          .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');
          // Make the value count up.
          if (config.valueCountUp) {
            var textTween = function() {
              var textStartValue = this.textContent.match(/\d+/)[0];
              var node = this;
              var i = d3.interpolate(parseInt(textStartValue), parseInt(textFinalValue));
              return function(t) {
                node.textContent = textFormat(i(t));
              }
            };

            text1.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);

            text2.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);
          }
          // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
          var waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;
          if (config.waveRise) {
            waveGroup
            .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')
            .transition()
            .duration(config.waveRiseTime)
            .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
            // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
            .on("start", function() { wave.attr('transform', 'translate(1,0)'); });
          } else {
            waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');
          }
          if (config.waveAnimate) animateWave();
          function animateWave() {
            wave.attr('transform', 'translate(' + waveAnimateScale(wave.attr('T')) + ',0)');
            wave.transition()
            .duration(config.waveAnimateTime * (
                1 - wave.attr('T')
              ))
            .ease(d3.easeLinear)
            .attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')
            .attr('T', 1)
            .on('end', function() {
              wave.attr('T', 0);
              animateWave(config.waveAnimateTime);
            });
          }

          function GaugeUpdater() {
            this.update = function(value) {
              var newFinalValue = parseFloat(value).toFixed(2);
              var textRounderUpdater = function(value) { return Math.round(value); };
              if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
                textRounderUpdater = function(value) { return parseFloat(value).toFixed(1); };
              }
              if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
                textRounderUpdater = function(value) { return parseFloat(value).toFixed(2); };
              }
              var textTween = function() {
                var i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));
                return function(t) {
                  this.textContent = textRounderUpdater(i(t));
                }
              };
              text1.transition()
              .duration(config.waveRiseTime)
              .tween("text", textTween);
              text2.transition()
              .duration(config.waveRiseTime)
              .tween("text", textTween);
              var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;
              var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);
              var waveRiseScale = d3.scaleLinear()
              // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
              // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
              // circle at 100%.
              .range([
                (
                  fillCircleMargin + fillCircleRadius * 2 + waveHeight
                ),
                (
                  fillCircleMargin - waveHeight
                )
              ])
              .domain([0, 1]);
              var newHeight = waveRiseScale(fillPercent);
              var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);
              var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);
              var newClipArea;
              if (config.waveHeightScaling) {
                newClipArea = d3.area()
                .x(function(d) { return waveScaleX(d.x); })
                .y0(function(d) {
                  return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (
                      1 - config.waveCount
                    ) + d.y * 2 * Math.PI));
                })
                .y1(function(d) {
                  return (
                    fillCircleRadius * 2 + waveHeight
                  );
                });
              } else {
                newClipArea = clipArea;
              }
              var newWavePosition = config.waveAnimate ? waveAnimateScale(1) : 0;
              wave.transition()
              .duration(0)
              .transition()
              .duration(config.waveAnimate ?
                        (
                          config.waveAnimateTime * (
                            1 - wave.attr('T')
                          )
                        ) :
                        (
                          config.waveRiseTime
                        ))
              .ease(d3.easeLinear)
              .attr('d', newClipArea)
              .attr('transform', 'translate(' + newWavePosition + ',0)')
              .attr('T', '1')
              .each("end", function() {
                if (config.waveAnimate) {
                  wave.attr('transform', 'translate(' + waveAnimateScale(0) + ',0)');
                  animateWave(config.waveAnimateTime);
                }
              });
              waveGroup.transition()
              .duration(config.waveRiseTime)
              .attr('transform', 'translate(' + waveGroupXPosition + ',' + newHeight + ')')
            }
          }

          return new GaugeUpdater();
        }

        function nodeRadius(node) {
          var data = node.data;
          var parent = node.parent;
          if(parent){
            return gauge_size(data.revenue / parent.data.revenue);
          }
          return ROOT_RADIUS;
        }

        // how much degree of the arc is off screen
        var START_ANGEL = 45;
        // how much degree to separate adjacent orbit items
        var MARGIN_ANGEL = 1;
        // total revenue size
        var ROOT_RADIUS = 80;
        // transition duration
        var DURATION = 750;
        // id counter seed
        var i = 0;
        var gauge_size = d3.interpolate(20, 200);
        var gauge_color = d3.scaleOrdinal([
          'rgba(117, 162, 234, 1)',
          'rgba(140, 211, 199, 1)',
          'rgba(204, 185, 92, 1)',
          'rgba(187, 128, 188, 1)',
          'rgba(128, 177, 211, 1)',
          'rgba(184, 188, 128, 1)',
          'rgba(157, 155, 191, 1)',
          'rgba(152, 186, 145, 1)'
        ]);

        function renderNode(node, i) {
          var config = gaugeDefaultConfig();
          var data = node.data;
          config.height = config.width = node.size * 2;
          config.circleColor = config.waveColor = gauge_color(i);
          config.waveAnimateTime = 5000;
          config.waveHeight = 0.15;
          config.waveOffset = 0.25;
          config.maxValue = data.revenue;
          config.node = node;
          config.isRoot = node.depth;
          config.showLabel = node.depth === 1; // only show label for depth one

          renderGauge(this, data.margin, config);
        }

        function layout_orbit(root, options) {
          var nodes = root.children;
          var margin = options.margin;
          var maxR = options.canvasRadius;
          var startDeg = options.start || 0;
          var endDeg = options.end || 180;
          var deg = startDeg;
          var lastDeg = 0;
          var thisDeg = 0;
          var max = 0;
          var radiusScale = d3.scaleLinear().domain([maxR, 0]).range([1, 0]);

          // item radius v.s. orbit radius
          var r, R = options.radius, degEach, scale = radiusScale(R);
          for (var i = 0, node, lastNode, length = nodes.length; node = nodes[i], i < length; i++) {
            r = nodeRadius(node) * scale;
            thisDeg = Math.atan(r / R) * (
              180 / Math.PI
              );

            node.x = deg + thisDeg + margin;
            node.y = R;
            node.size = r;
            node.scale = scale;

            var _circleCenter = project(node.x, node.y);

            node.circle = {
              r: node.size,
              center: _circleCenter,
              peak: [_circleCenter[0], _circleCenter[1] - node.size]
            };

            // degree increments
            deg += ( thisDeg + margin ) * 2;

            if (deg < endDeg) {
              max++;
            } else {
              break;
            }
          }
          // layout the root
          root.x = 90;
          root.y = Math.sin(START_ANGEL * Math.PI / 180) * R - 100;
          root.size = ROOT_RADIUS;
          root.children = root.children.slice(0, max);

          var _rootCircleCenter = project(root.x, root.y);

          root.circle = {
            r: root.size,
            center: _rootCircleCenter,
            peak: [_rootCircleCenter[0], _rootCircleCenter[1] - root.size]
          };

          return deg - startDeg;
        }

        function linkStraight(source, target) {
          return 'M' + project(source.x, source.y) + 'L' + project(target.x, target.y);
        }

        Polymer({
          is: 'device-revenue-chart',
          properties: {
            data: {
              type: Object,
              observer: 'replot'
            },
            width: Number,
            height: Number
          },
          replot: function() {
            var _this = this;
            var _opening = null;

            var tree = d3.hierarchy(this.data);
            // layout start
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              rootGroup = svg.append("g")
              .attr('class', 'orbit1')
              .attr("transform",
              "translate(" + (
                width / 2
              ) + "," + (
                height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200
              ) + ")"
            );

            layout_orbit(tree, {
              start: START_ANGEL,
              end: 180 - START_ANGEL,
              radius: radius,
              canvasRadius: width / 2,
              margin: MARGIN_ANGEL
            });

            var nodes = tree.descendants();
            var links = tree.links();

            var link = rootGroup.selectAll('.link')
            .data(nodes.slice(1), function(d) {
              return d.data.id;
            });

            // Enter any new links at the parent's previous position.
            var linkEnter = link.enter().append('path')
            .attr('class', 'link')
            .attr('d', function(d) {
              // the origin and endpoint is the same: circle peak of parent
              return 'M' + d.parent.circle.peak + 'L' + d.parent.circle.peak;
            });

            var linkUpdate = link.merge(linkEnter)
            .transition()
            .duration(DURATION)
            .attr('d', function(d) {
              // origin: circle peak of parent
              // endpoint: circle center of current node
              return 'M' + d.parent.circle.peak + 'L' + d.circle.center;
            });

            // Update the nodes
            var node = rootGroup.selectAll('g.node')
            .data(nodes, function(d) {
              return d.data.id || (d.data.id = ++i);
            });

            var nodeEnter = node.enter().append('g')
            .attr('class', function(d) {
              return 'node ' + (d.children ? 'node--internal' : 'node--leaf');
            })
            .attr('transform', function(d) {
              // keep original position same as tree root
              var _node = d.parent ? d.parent : d;
              return 'translate(' + _node.circle.center + ')';
            })
            .attr('id', function(d) {
              return 'node-' + d.data.id;
            })
            .style('cursor', 'pointer')
            .on('click', handleClick)
            .each(renderNode);

            // Transition child nodes to their new position.
            var nodeUpdate = node.merge(nodeEnter)
            .transition()
            .duration(DURATION)
            .attr('transform', function(d) {
              // move to own position
              return 'translate(' + d.circle.center + ')';
            });

            // Save previous position
            nodes.forEach(function(d) {
              d.x0 = d.x;
              d.y0 = d.y;
              d.circle0 = d.circle;
            });

            this.scopeSubtree(this.$.chart, true);

            function resetOrbit1() {
              // reset to render subtree
              node.merge(nodeUpdate)
              .data(tree.descendants())
              .filter(function(d) {
                return d.parent;
              })
              .transition()
              .duration(DURATION)
              .attr('transform', function(d) {
                // move to original position
                return 'translate(' + d.circle0.center + ')';
              })
              .each(function(d, i, nodeList) {
                // reset the gauge size and position
                d3.select(nodeList[i])
                .select('g.gauge')
                .transition()
                .duration(DURATION)
                .attr('transform', function(d) {
                  var pos = [d.size, d.size].map(function(n) {
                    return -n;
                  });
                  return 'translate(' + pos.join(',') + ')';
                });
              });

              link.merge(linkUpdate)
              .data(tree.descendants().slice(1))
              .transition()
              .duration(DURATION)
              .attr('d', function(d) {
                // origin: circle0 peak of parent
                // endpoint: circle0 center of current node
                // circle0 is an alias of the previous circle
                return 'M' + d.parent.circle0.peak + 'L' + d.circle0.center;
              });
            }

            function handleClick(targetNode, i, nodeList) {
              // remove all `active` class for each node
              d3.selectAll(nodeList)
              .classed('active', false);

              if (targetNode.parent) {
                // add `expanded` for root node when orbit two open
                svg.classed('expanded', true);

                // add `active` class for current node in orbit one
                d3.select(nodeList[i])
                .classed('active', true);

                // build a new smaller tree layout
                var new_radius = radius - 200;
                layout_orbit(tree, {
                  start: START_ANGEL,
                  end: 180 - START_ANGEL,
                  radius: new_radius,
                  canvasRadius: width / 2,
                  margin: MARGIN_ANGEL
                });
                // rerender subtree's children
                node.merge(nodeUpdate)
                .data(tree.descendants())
                .transition()
                .duration(DURATION)
                .filter(function(d) {
                  return d.parent;
                })
                .attr('transform', function(d) {
                  return 'translate(' + d.circle.center + ')';
                })
                .on('end', function(d) {
                  // when this opening node is in position.
                  if (d.data.id === targetNode.data.id) {
                    _opening = openNode(targetNode);
                  }
                })
                .each(function(d, i, nodeList) {
                  // make the orbit and gauge smaller
                  d3.select(nodeList[i])
                  .select('g.gauge')
                  .transition()
                  .duration(DURATION)
                  .attr('transform', function(d) {
                    var scale = Math.pow(d.scale, 3);

                    // Stash origin scale and peak
                    d.scale0 = d.scale;
                    d.circle.peak0 = d.circle.peak;
                    // replace `scale` && `peak` field with new value
                    d.scale = scale;
                    d.circle.peak = [d.circle.center[0], d.circle.center[1] - scale * d.circle.r];

                    var pos = [d.size, d.size].map(function(n) {
                      return -n * scale;
                    });

                    return 'translate(' + pos.join(',') + ')' + ' scale(' + scale + ')';
                  });
                });

                link.merge(linkUpdate)
                .data(tree.descendants().slice(1))
                .transition()
                .duration(DURATION)
                .attr('d', function(d) {
                  // origin: circle0 peak of parent
                  // endpoint: circle center of current node
                  // circle0 is an alias of the previous circle
                  return 'M' + d.parent.circle0.peak + 'L' + d.circle.center;
                });
              } else {
                // remove `expanded` for root node when orbit two closed
                svg.classed('expanded', false);

                // check if there's a 2nd orbit now
                if (_opening) {
                  _opening.then(function(closeNode) {
                    closeNode().then(resetOrbit1);
                  })
                } else {
                  resetOrbit1();
                }
              }
            }

            function openNode(node) {
              // check node already opened
              if (_this.$.chartSvg.querySelector('#tree--' + node.data.id)) {
                return Promise.resolve(false);
              }

              return _this.handleRequestNode(node).then(function layoutOrbit2(data) {
                var subTree = d3.hierarchy(data);
                subTree.data = node.parent.data;
                svg.select('.orbit2').remove();

                var subGroup =
                  svg.insert("g", ':first-child')
                  .attr('class', 'orbit2')
                  .attr('id', 'tree--'+node.data.id)
                  .attr("transform",
                  "translate(" + (
                    width / 2
                  ) + "," + (
                    height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200
                  ) + ")"
                );

                // calc start angle
                var arcDeg = layout_orbit(subTree, {
                  start: START_ANGEL,
                  end: 180 - START_ANGEL,
                  radius: radius,
                  canvasRadius: width / 2,
                  margin: MARGIN_ANGEL / 2
                });

                var startDeg;
                var parentDeg = node.x - START_ANGEL;
                var totalDeg = 180 - START_ANGEL * 2;
                if (arcDeg / 2 < parentDeg) {
                  startDeg = parentDeg - arcDeg/2;
                } else if(arcDeg / 2 > parentDeg) {
                  startDeg = 0;
                }
                startDeg += START_ANGEL;

                // calc start angle
                var arcDeg = layout_orbit(subTree, {
                  start: startDeg,
                  end: 180 - START_ANGEL,
                  radius: radius,
                  canvasRadius: width / 2,
                  margin: MARGIN_ANGEL / 2
                });

                var nodes = subTree.descendants().slice(1);
                var links = subTree.links();
                var link = subGroup.selectAll('.link')
                .data(nodes, function(d) {
                  return d.data.id;
                });

                // Enter any new links at the parent's previous position.
                var linkEnter = link.enter().append('path')
                .attr('class', 'link')
                .attr('d', function(d) {
                  // origin and endpoint are the same
                  return 'M' + node.circle.peak + 'L' + node.circle.peak;
                });

                var linkUpdate = link.merge(linkEnter)
                .transition()
                .delay(DURATION/2)
                .duration(DURATION/2)
                .ease(d3.easeQuadOut)
                .attr('d', function(d, i) {
                  // origin: circle peak of parent (named `node` here)
                  // endpoint: circle center of current node
                  return 'M' + node.circle.peak + 'L' + d.circle.center;

                  // var controlPos = [
                  //   sourcePos[0] + (targetPos[0] - sourcePos[0]) * 0.4,
                  //   sourcePos[1] + (targetPos[1] - sourcePos[1]) * 0.65
                  // ];

                  // return 'M' + source.circle.peak + 'Q' + controlPos + ',' + d.circle.center;
                });

                var groups = subGroup.selectAll('g.node')
                .data(nodes, function(d) {
                  return d.data.id || (
                      d.data.id = ++i
                    )
                });

                var nodeEnter = groups.enter().append("g")
                .attr("class", function(d) {
                  return "node" + (
                      d.children ? " node--internal" : " node--leaf"
                    );
                })
                .attr("transform", function(d) {
                  // original position (parent `node` circle center)
                  return 'translate(' + node.circle.center + ')';
                })
                .attr('id', function(d) {
                  return 'node-' + d.data.id;
                })
                .each(renderNode);

                // Transition nodes to their new position.
                var nodeUpdate = groups.merge(nodeEnter)
                .transition()
                .duration(DURATION/2)
                .attr('transform', function(d) {
                  // own position
                  return 'translate(' + d.circle.center + ')';
                });

                return function closeNode() {
                  return new Promise(function(resolve, reject) {
                    // reset to render subtree
                    groups.merge(nodeUpdate)
                    .data(subTree.descendants())
                    .transition()
                    .duration(DURATION / 2)
                    .attr('transform', function(d) {
                      // back to original position (parent `node` circle center)
                      return 'translate(' + node.circle.center + ')';
                    })
                    .on('end', function(d, i) {
                      // when orbit 2 is closed
                      if (i === 0) {
                        subGroup.remove();
                        resolve();
                      }
                    })

                    link.merge(linkUpdate)
                    .data(subTree.descendants())
                    .transition()
                    .duration(DURATION / 2)
                    .attr('d', function(d) {
                      // back to original position (parent `node` circle peak)
                      return 'M' + node.circle.peak + 'L' + node.circle.peak;
                    });
                  });
                }
              });
            }
          },
          handleRequestNode: function(node) {
            var nodeId = node.data.id;
            if(nodeId > 3){
              nodeId = 2;
            }
            nodeId = 3;
            return fetch('mock/revenue-data-' + nodeId + '.json').then(function(res) {
              return  res.json();
            });
          },

          ready: function() {
            var _this = this;
            var rect = this.$.chart.getBoundingClientRect();
            this.set('width', rect.width);
            this.set('height', rect.height);
            fetch('mock/revenue-data.json').then(function(res) {
              return res.json();
            }).then(function(data) {
              _this.set('data', data);
            });
          }
        });
      }
    )();
  </script>
</dom-module>