<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="device-revenue-chart-styles.html">
<script src="../../bower_components/d3-transform/src/d3-transform.js"></script>
<script src="../../bower_components/lscache/lscache.js"></script>
<script src="../../bower_components/urijs/src/URI.js"></script>

<dom-module id="device-revenue-chart">
  <template>
    <style include="device-revenue-chart-styles"></style>
    <div id="chart" class="chart-container">
      <svg id="chartSvg" width$="[[width]]" height$="[[height]]"></svg>
    </div>
  </template>
  <script>
    (
      function() {
        function project(x, radius) {
          var angle = ( x - 180 ) / 180 * Math.PI;
          return [radius * Math.cos(angle), radius * Math.sin(angle)];
        }

        function gaugeDefaultConfig() {
          return {
            width: 100, // The gauge minimum value.
            height: 100, // The gauge minimum value.
            minValue: 0, // The gauge minimum value.
            maxValue: 100, // The gauge maximum value.
            circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.
            circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.
            circleColor: "#178BCA", // The color of the outer circle.
            waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.
            waveCount: 1, // The number of full waves per width of the wave circle.
            waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.
            waveAnimateTime: 18000, // The amount of time in milliseconds for a full wave to enter the wave circle.
            waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.
            waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.
            waveAnimate: true, // Controls if the wave scrolls or is static.
            waveColor: "#178BCA", // The color of the fill wave.
            waveOffset: 0, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.
            textVertPosition: .5, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.
            textSize: 1, // The relative height of the text to display in the wave circle. 1 = 50%
            valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.
            textColor: "#045681", // The color of the value text when the wave does not overlap it.
            waveTextColor: "#fff" // The color of the value text when the wave overlaps it.
          };
        }

        function renderGauge(element, value, config) {
          if (config == null) {
            config = gaugeDefaultConfig();
          }
          var gauge = d3.select(element);
          var radius = Math.min(config.width, config.height) / 2;
          var locationX = -parseInt(config.width) / 2;
          var locationY = -parseInt(config.height) / 2;
          var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;
          var waveHeightScale;
          if (config.waveHeightScaling) {
            waveHeightScale = d3.scaleLinear()
            .range([0, config.waveHeight, 0])
            .domain([0, 50, 100]);
          } else {
            waveHeightScale = d3.scaleLinear()
            .range([config.waveHeight, config.waveHeight])
            .domain([0, 100]);
          }
          var textPixels = (
            config.textSize * radius / 2
          );
          var textFinalValue = parseFloat(value).toFixed(2);
          var textStartValue = config.valueCountUp ? config.minValue : textFinalValue;
          var circleThickness = config.circleThickness * radius;
          var circleFillGap = config.circleFillGap * radius;
          var fillCircleMargin = circleThickness + circleFillGap;
          var fillCircleRadius = radius - fillCircleMargin;
          var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);
          var waveLength = fillCircleRadius * 2 / config.waveCount;
          var waveClipCount = 1 + config.waveCount;
          var waveClipWidth = waveLength * waveClipCount;
          var data = config.node.data;
          var labelUnit = data.label_unit;

          // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
          var textFormat = function(value) { return Math.round(value) + labelUnit; };
          if (parseFloat(textFinalValue) != parseFloat(textFormat(textFinalValue))) {
            textFormat = function(value) { return parseFloat(value).toFixed(1); };
          }
          if (parseFloat(textFinalValue) != parseFloat(textFormat(textFinalValue))) {
            textFormat = function(value) { return parseFloat(value).toFixed(2); };
          }

          // Data for building the clip wave area.
          var data = [];
          for (var i = 0; i <= 40 * waveClipCount; i++) {
            data.push({
              x: i / (
                40 * waveClipCount
              ),
              y: (
                i / (
                  40
                )
              )
            });
          }
          // Scales for drawing the outer circle.
          var gaugeCircleX = d3.scaleLinear().range([0, 2 * Math.PI]).domain([0, 1]);
          var gaugeCircleY = d3.scaleLinear().range([0, radius]).domain([0, radius]);
          // Scales for controlling the size of the clipping path.
          var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);
          var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);
          // Scales for controlling the position of the clipping path.
          var waveRiseScale = d3.scaleLinear()
          // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
          // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
          // circle at 100%.
          .range([fillCircleMargin + fillCircleRadius * 2 + waveHeight, fillCircleMargin-waveHeight])
          .domain([0, 1]);
          var waveAnimateScale = d3.scaleLinear()
          .range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.
          .domain([0, 1]);

          // Scale for controlling the position of the text within the gauge.
          var textRiseScaleY = d3.scaleLinear()
          .range([fillCircleMargin + fillCircleRadius*2, fillCircleMargin + (fillCircleRadius * 2* (1-fillPercent)) + textPixels * 0.7])
          .domain([0, 1]);

          // Center the gauge within the parent SVG.
          var gaugeGroup = gauge.append("g")
          .attr('class', 'gauge')
          .attr('transform', 'translate(' + locationX + ',' + locationY + ')');
          gaugeGroup.append("circle")
          .attr("r", gaugeCircleY(radius))
          .style("fill", '#fff')
          .style("stroke", config.circleColor)
          .style("stroke-width", gaugeCircleY(circleThickness))
          .attr('transform', 'translate(' + radius + ',' + radius + ')');
          
          // Text to show current node's name
          // at least depth over 0
          if (config.showLabel) {
            var node = config.node;
            var distance = 30;
            var r = gaugeCircleY(radius);
            var _radius = r + distance;

            // position according to center of the circle
            var absolutePos = project(node.x, node.y);
            var x0 = Math.abs(absolutePos[0]);
            var y0 = Math.abs(absolutePos[1]);

            // distance tree root center of the circle
            // the line between these two pointers is vertical
            var root2Center = Math.sin(START_ANGEL * Math.PI/180) * node.y;

            // position according to tree root node
            var x = x0;
            var y = Math.abs(y0 - root2Center);

            var distance2Parent = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));

            var x0 = x / distance2Parent * _radius;
            var y0 = y / distance2Parent * _radius;

            var pos = [x0, y0];
            if (absolutePos[0] === 0) pos = [0, y0];
            if (absolutePos[0] > 0) pos = [-x0, y0];
            
            // draw text to this group
            gauge.append('g')
            .attr('transform', function() {
              return 'translate(' + pos.join(',') + ')';
            })
            .append('text')
            .attr('class', 'link-label')
            .attr('text-anchor', 'middle')
            .attr('fill', config.waveColor)
            .text(node.data.name);
          }

          // Text where the wave does not overlap.
          var text1 = gaugeGroup.append("text")
          .text(textFormat(textStartValue))
          .attr("class", "liquidFillGaugeText")
          .attr("text-anchor", "middle")
          .attr("font-size", textPixels + "px")
          .style("fill", config.textColor)
          .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');
          // The clipping wave area.
          var clipArea = d3.area()
          .x(function(d) { return waveScaleX(d.x); })
          .y0(function(d) {
            return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (
                1 - config.waveCount
              ) + d.y * 2 * Math.PI));
          })
          .y1(function(d) {
            return (
              fillCircleRadius * 2 + waveHeight
            );
          });
          var clip_wave_id = gauge.attr('id');
          var waveGroup = gaugeGroup.append("defs")
          .append("clipPath")
          .attr("id", "clipWave" + clip_wave_id);
          var wave = waveGroup.append("path")
          .datum(data)
          .attr("d", clipArea)
          .attr("T", 0);
          // The inner circle with the clipping wave attached.
          var fillCircleGroup = gaugeGroup.append("g")
          .attr("clip-path", "url(#clipWave" + clip_wave_id + ")");
          fillCircleGroup.append("circle")
          .attr("cx", radius)
          .attr("cy", radius)
          .attr("r", fillCircleRadius)
          .style("fill", config.waveColor);

          // Text where the wave does overlap.
          var text2 = fillCircleGroup.append("text")
          .text(textFormat(textStartValue))
          .attr("class", "liquidFillGaugeText")
          .attr("text-anchor", "middle")
          .attr("font-size", textPixels + "px")
          .style("fill", config.waveTextColor)
          .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');
          // Make the value count up.
          if (config.valueCountUp) {
            var textTween = function() {
              var textStartValue = this.textContent.match(/\d+/)[0];
              var node = this;
              var i = d3.interpolate(parseInt(textStartValue), parseInt(textFinalValue));
              return function(t) {
                node.textContent = textFormat(i(t));
              }
            };

            text1.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);

            text2.transition()
            .duration(config.waveRiseTime)
            .tween("text", textTween);
          }
          // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
          var waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;
          if (config.waveRise) {
            waveGroup
            .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')
            .transition()
            .duration(config.waveRiseTime)
            .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
            // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
            .on("start", function() { wave.attr('transform', 'translate(1,0)'); });
          } else {
            waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');
          }
          if (config.waveAnimate) animateWave();
          function animateWave() {
            wave.attr('transform', 'translate(' + waveAnimateScale(wave.attr('T')) + ',0)');
            wave.transition()
            .duration(config.waveAnimateTime * (
                1 - wave.attr('T')
              ))
            .ease(d3.easeLinear)
            .attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')
            .attr('T', 1)
            .on('end', function() {
              wave.attr('T', 0);
              animateWave(config.waveAnimateTime);
            });
          }

          function GaugeUpdater() {
            this.update = function(value) {
              var newFinalValue = parseFloat(value).toFixed(2);
              var textRounderUpdater = function(value) { return Math.round(value); };
              if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
                textRounderUpdater = function(value) { return parseFloat(value).toFixed(1); };
              }
              if (parseFloat(newFinalValue) != parseFloat(textRounderUpdater(newFinalValue))) {
                textRounderUpdater = function(value) { return parseFloat(value).toFixed(2); };
              }
              var textTween = function() {
                var i = d3.interpolate(this.textContent, parseFloat(value).toFixed(2));
                return function(t) {
                  this.textContent = textRounderUpdater(i(t));
                }
              };
              text1.transition()
              .duration(config.waveRiseTime)
              .tween("text", textTween);
              text2.transition()
              .duration(config.waveRiseTime)
              .tween("text", textTween);
              var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;
              var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);
              var waveRiseScale = d3.scaleLinear()
              // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
              // such that the it will overlap the fill circle at all when at 0%, and will totally cover the fill
              // circle at 100%.
              .range([
                (
                  fillCircleMargin + fillCircleRadius * 2 + waveHeight
                ),
                (
                  fillCircleMargin - waveHeight
                )
              ])
              .domain([0, 1]);
              var newHeight = waveRiseScale(fillPercent);
              var waveScaleX = d3.scaleLinear().range([0, waveClipWidth]).domain([0, 1]);
              var waveScaleY = d3.scaleLinear().range([0, waveHeight]).domain([0, 1]);
              var newClipArea;
              if (config.waveHeightScaling) {
                newClipArea = d3.area()
                .x(function(d) { return waveScaleX(d.x); })
                .y0(function(d) {
                  return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (
                      1 - config.waveCount
                    ) + d.y * 2 * Math.PI));
                })
                .y1(function(d) {
                  return (
                    fillCircleRadius * 2 + waveHeight
                  );
                });
              } else {
                newClipArea = clipArea;
              }
              var newWavePosition = config.waveAnimate ? waveAnimateScale(1) : 0;
              wave.transition()
              .duration(0)
              .transition()
              .duration(config.waveAnimate ?
                        (
                          config.waveAnimateTime * (
                            1 - wave.attr('T')
                          )
                        ) :
                        (
                          config.waveRiseTime
                        ))
              .ease(d3.easeLinear)
              .attr('d', newClipArea)
              .attr('transform', 'translate(' + newWavePosition + ',0)')
              .attr('T', '1')
              .each("end", function() {
                if (config.waveAnimate) {
                  wave.attr('transform', 'translate(' + waveAnimateScale(0) + ',0)');
                  animateWave(config.waveAnimateTime);
                }
              });
              waveGroup.transition()
              .duration(config.waveRiseTime)
              .attr('transform', 'translate(' + waveGroupXPosition + ',' + newHeight + ')')
            }
          }

          return new GaugeUpdater();
        }

        function nodeRadius(node) {
          var data = node.data;
          var parent = node.parent;
          if(parent){
            return gauge_size(data.revenue / parent.data.revenue);
          }
          return ROOT_RADIUS;
        }

        // how much degree of the arc is off screen
        var START_ANGEL = 45;
        var PAGINATION_BUFFER = 0;
        var PAGER_BORDER_COLOR = 'rgba(177,177,188, 1)';
        var PAGER_START_ANGEL = START_ANGEL - 3;
        // how much degree to separate adjacent orbit items
        var MARGIN_ANGEL = 1;
        // total revenue size
        var ROOT_RADIUS = 80;
        // transition duration
        var DURATION = 750;
        // page transition duration
        var DURATION_PAGING = 1000;
        var PAGER_RADIUS = 20;
        // id counter seed
        var i = 0;
        var gauge_size = d3.interpolate(20, 80);
        var gauge_color = d3.scaleOrdinal([
          'rgba(117, 162, 234, 1)',
          'rgba(140, 211, 199, 1)',
          'rgba(204, 185, 92, 1)',
          'rgba(187, 128, 188, 1)',
          'rgba(128, 177, 211, 1)',
          'rgba(184, 188, 128, 1)',
          'rgba(157, 155, 191, 1)',
          'rgba(152, 186, 145, 1)'
        ]);

        function renderNode(node, i) {
          var config = gaugeDefaultConfig();
          var data = node.data;
          config.height = config.width = node.size * 2;
          config.circleColor = config.waveColor = gauge_color(i);
          config.waveAnimateTime = 5000;
          config.waveHeight = 0.15;
          config.waveOffset = 0.25;
          config.maxValue = data.revenue;
          config.node = node;
          config.isRoot = node.depth;
          config.showLabel = node.depth === 1; // only show label for depth one

          renderGauge(this, data.profit, config);
        }

        function layout_orbit(root, options) {
          var nodes = root.children;
          var margin = options.margin;
          var maxR = options.canvasRadius;
          var startDeg = options.start || 0;
          var endDeg = options.end || 180;
          var deg = startDeg;
          var lastDeg = 0;
          var thisDeg = 0;
          var max = 0;
          var radiusScale = d3.scaleLinear().domain([maxR, 0]).range([1, 0]);

          // item radius v.s. orbit radius
          var r, R = options.radius, degEach, scale = radiusScale(R);
          for (var i = 0, node, lastNode, length = nodes.length; node = nodes[i], i < length; i++) {
            r = nodeRadius(node) * scale;
            thisDeg = Math.atan(r / R) * (
              180 / Math.PI
              );

            node.x = deg + thisDeg + margin;
            node.y = R;
            node.size = r;
            node.scale = scale;

            var _circleCenter = project(node.x, node.y);

            node.circle = {
              r: node.size,
              center: _circleCenter,
              peak: [_circleCenter[0], _circleCenter[1] - node.size]
            };

            // degree increments
            deg += ( thisDeg + margin ) * 2;

            if (deg < endDeg) {
              max++;
            } else {
              break;
            }
          }
          // layout the root
          root.x = 90;
          root.y = Math.sin(START_ANGEL * Math.PI / 180) * R - 100;
          root.size = ROOT_RADIUS;
          root.children = root.children.slice(0, max);

          var _rootCircleCenter = project(root.x, root.y);

          root.circle = {
            r: root.size,
            center: _rootCircleCenter,
            peak: [_rootCircleCenter[0], _rootCircleCenter[1] - root.size]
          };

          return {
            count: max,
            deg: deg - startDeg
          };
        }

        function formatConvert(data) {
          return Object.assign({}, data, {
            id: i++,
            revenue: parseFloat(data.revenue_label),
            profit: parseFloat(data.profit_label)
          });
        }

        function parseTransformRotate(element) {
          var rotate;
          var match = element.getAttribute('transform').match(/rotate\(([^)]+)\)/);
          if (match) {
            rotate = match[1].split(',');
            return {
              deg: rotate[0],
              x: +rotate[1],
              y: +rotate[2]
            };
          }
          return null;
        }

        function rotateToTween(dest) {
          return function transform() {
            var rotate = parseTransformRotate(this);
            var interpolate = d3.interpolateNumber(rotate.deg, dest);
            return function(t) {
              var deg = interpolate(t);
              return d3Transform().rotate(deg, rotate.x, rotate.y)();
            };
          }
        }

        function rotate(dest) {
          return function() {
            var rotate = parseTransformRotate(this);
            return d3Transform().rotate(dest, rotate.x, rotate.y)();
          }
        }

        function pageEntered(page) {
          // remove opacity inline styles
          var $el = d3.select(this).style('opacity', '');
          $el.classed('curr-page next-page prev-page', false);
          $el.classed(page + '-page', true);
        }

        Polymer({
          is: 'device-revenue-chart',
          properties: {
            data: {
              type: Object,
              observer: 'replot'
            },
            _pageStartHistoryL1: {
              type: Array,
              value: []
            },
            _pageStartHistoryL2: {
              type: Array,
              value: []
            },
            pageLastStartL1: {
              type: Number
            },
            pageStartL1: {
              type: Number,
              value: 0,
              observer: '_pageChangedL1'
            },
            pageStartL2: {
              type: Number,
              value: 0,
              observer: '_pageChangedL2'
            },
            pageOffsetL1: {
              type: Number,
              value: 0
            },
            pageEndL1: {
              type: Number,
              value: 0
            },
            isPaging: {
              type: Boolean,
              value: false,
              observer: 'enterLeavePaging'
            },
            openingNodeL1: {
              type: Object
            },
            width: Number,
            height: Number
          },
          observers: [
            '_computeLastStartL1(_pageStartHistoryL1.*)',
            '_computeLastStartL2(_pageStartHistoryL2.*)'
          ],
          plotRoot: function(root) {
            var _this = this;
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              offsetX = width / 2,
              offsetY = height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200;

            var node = {
              data: root,
              x: 90,
              y: Math.sin(START_ANGEL * Math.PI / 180) * radius - 100,
              size: ROOT_RADIUS,
              parent: null
            };

            var canvas = svg.append("g")
            .attr('transform', d3Transform().rotate(0, width / 2, offsetY))
            .attr("transform", "translate(" + offsetX + "," + offsetY + ")");

            // Update the nodes
            canvas.selectAll('g.node')
            .data([node]).enter().append("g")
            .attr("transform", function(d) {
              return "translate(" + project(d.x, d.y) + ")";
            })
            .style('cursor', 'pointer')
            .on('click', function handleClickRoot() {
              // remove `expanded` for root node when orbit two closed
              svg.classed('expanded', false);
              // check if there's a 2nd orbit now
              if (_this.openingNodeL1) {
                _this.closeNodeL1().then(function() {
                  delete _this.openingNodeL1;
                  _this.resetOrbitL1();
                });
              }
            })
            .each(renderNode);
          },
          plotPager: function(url, level) {
            var _this = this;
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              offsetX = width / 2,
              offsetY = height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200;

            var list = lscache.get(url) || [];
            var pages = lscache.get(url + '/pages');
            var total = pages? pages.total : list.length;
            var hasNext = total > this.get('pageOffsetL'+level);
            var hasPrev = this.get('pageStartL'+level) > 0;

            var pagers = [
              {
                type: 'prev',
                enabled: hasPrev,
                x: PAGER_START_ANGEL,
                y: radius,
              },
              {
                type: 'next',
                enabled: hasNext,
                x: 180 - PAGER_START_ANGEL,
                y: radius,
              }
            ];

            var canvas = svg.select('g.pagination');
            if (canvas.empty()) {
              canvas = svg.append("g")
              .attr('class', 'pagination')
              .attr('transform', d3Transform().rotate(0, width / 2, offsetY))
              .attr("transform", "translate(" + offsetX + "," + offsetY + ")");
            }

            var nodes = canvas.selectAll('g.pager').data(pagers, function(d) {
              return d.type;
            });

            nodes = nodes.enter().append("g")
            .attr('class', 'pager')
            .attr("transform", function(d) {
              return "translate(" + project(d.x, d.y) + ")";
            })
            .merge(nodes);

            nodes.style('display', function(d) {
              return d.enabled? 'block': 'none';
            }).each(function(d) {
              var root = d3.select(this);

              var nodes = root.selectAll('g.page-btn').data([d], function(d) { return d.type; });
              var nodes_enter = nodes.enter().append("g").attr('class', 'page-btn');

              nodes_enter.append("circle")
              .attr("cx", PAGER_RADIUS / 2)
              .attr("cy", PAGER_RADIUS / 2)
              .attr("r", PAGER_RADIUS)
              .style("fill", 'transparent')
              .style("stroke", PAGER_BORDER_COLOR)
              .style("stroke-width", "2px")
              .attr('class', function(d) {
                return 'btn-' + d.type;
              });

              nodes_enter.append('path')
              .attr('d', d3.symbol().type(d3.symbolTriangle).size(PAGER_RADIUS * 10))
              .attr('transform',
                d3Transform()
                .translate(PAGER_RADIUS / 2, PAGER_RADIUS / 2)
                .rotate(180))
              .style('fill', PAGER_BORDER_COLOR);

              nodes = nodes.merge(nodes_enter);
              nodes.on('click', null).on('click', function handlePagerClick() {
                var type = d.type;
                type === 'next' ? _this.openNextPage(url, level) : _this.openPrevPage(url, level);
              });
            });
          },
          plotL1: function(root, children) {
            var data = Object.assign({children: children}, root);
            var _this = this;
            var _opening = null;
            var tree = d3.hierarchy(data);

            // layout start
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              offsetX = width / 2,
              offsetY = height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200;

            var canvas = svg.insert('g', ':first-child')
              .attr('class', 'orbit1')
              .attr('transform', d3Transform().rotate(0, width / 2, offsetY))

            var rootGroup = canvas.append("g");
            rootGroup.attr("transform", "translate(" + offsetX+ "," + offsetY + ")");
            var result = layout_orbit(tree, {
              start: START_ANGEL,
              end: 180 - START_ANGEL,
              radius: radius,
              canvasRadius: width / 2,
              margin: MARGIN_ANGEL
            });

            var nodes = tree.descendants();
            var links = tree.links();

            var link = rootGroup.selectAll('.link')
            .data(nodes.slice(1), function(d) {
              return d.data.id;
            });

            // Enter any new links at the parent's previous position.
            var linkEnter = link.enter().append('path')
            .attr('class', 'link')
            .attr('d', function(d) {
              // the origin and endpoint is the same: circle peak of parent
              return 'M' + d.parent.circle.peak + 'L' + d.parent.circle.peak;
            });

            var linkUpdate = link.merge(linkEnter)
            .transition()
            .duration(DURATION)
            .attr('d', function(d) {
              // origin: circle peak of parent
              // endpoint: circle center of current node
              return 'M' + d.parent.circle.peak + 'L' + d.circle.center;
            });

            // Update the nodes
            var node = rootGroup.selectAll('g.node')
            .data(nodes.slice(1), function(d) {
              return d.data.id || (d.data.id = ++i);
            });

            var nodeEnter = node.enter().append('g')
            .attr('class', function(d) {
              return 'node ' + (d.children ? 'node--internal' : 'node--leaf');
            })
            .attr('transform', function(d) {
              // keep original position same as tree root
              var _node = d.parent ? d.parent : d;
              return 'translate(' + _node.circle.center + ')';
            })
            .attr('id', function(d) {
              return 'node-' + d.data.id;
            })
            .style('cursor', 'pointer')
            .on('click', handleClick)
            .each(renderNode);

            // Transition child nodes to their new position.
            var nodeUpdate = node.merge(nodeEnter)
            .transition()
            .duration(DURATION)
            .attr('transform', function(d) {
              // move to own position
              return 'translate(' + d.circle.center + ')';
            });

            // Save previous position
            nodes.forEach(function(d) {
              d.x0 = d.x;
              d.y0 = d.y;
              d.circle0 = d.circle;
            });

            this.scopeSubtree(this.$.chart, true);

            return Object.assign(result, {
              element: canvas
            });

            function handleClick(targetNode, i, nodeList) {
              // remove all `active` class for each node
              d3.selectAll(nodeList)
              .classed('active', false);

              if (targetNode.parent) {
                // add `expanded` for root node when orbit two open
                svg.classed('expanded', true);

                // add `active` class for current node in orbit one
                d3.select(nodeList[i])
                .classed('active', true);

                // build a new smaller tree layout
                var new_radius = radius - 200;
                layout_orbit(tree, {
                  start: START_ANGEL,
                  end: 180 - START_ANGEL,
                  radius: new_radius,
                  canvasRadius: width / 2,
                  margin: MARGIN_ANGEL
                });

                // rerender subtree's children
                rootGroup.selectAll('g.node')
                .transition()
                .duration(DURATION)
                .filter(function(d) {
                  return d.parent;
                })
                .attr('transform', function(d) {
                  return 'translate(' + d.circle.center + ')';
                })
                .on('end', function(d) {
                  // when this opening node is in position.
                  if (d.data.id === targetNode.data.id) {
                    _this.handleOpenNode(targetNode);
                  }
                })
                .each(function(d, i, nodeList) {
                  // make the orbit and gauge smaller
                  d3.select(nodeList[i])
                  .select('g.gauge')
                  .transition()
                  .duration(DURATION)
                  .attr('transform', function(d) {
                    var scale = Math.pow(d.scale, 3);

                    // Stash origin scale and peak
                    d.scale0 = d.scale;
                    d.circle.peak0 = d.circle.peak;
                    // replace `scale` && `peak` field with new value
                    d.scale = scale;
                    d.circle.peak = [d.circle.center[0], d.circle.center[1] - scale * d.circle.r];

                    var pos = [d.size, d.size].map(function(n) {
                      return -n * scale;
                    });

                    return 'translate(' + pos.join(',') + ')' + ' scale(' + scale + ')';
                  });
                });

                rootGroup.selectAll('.link')
                .transition()
                .duration(DURATION)
                .attr('d', function(d) {
                  // origin: circle0 peak of parent
                  // endpoint: circle center of current node
                  // circle0 is an alias of the previous circle
                  return 'M' + d.parent.circle0.peak + 'L' + d.circle.center;
                });
              }
            }
          },
          plotL2: function(parent, children) {
            // layout start
            var svg = d3.select(this.$.chartSvg),
              width = +svg.attr("width"),
              height = +svg.attr("height"),
              radius = width / 2 + 150,
              offsetX = width / 2,
              offsetY = height + Math.sin(START_ANGEL * Math.PI / 180) * radius - 200;

            var canvas = svg.insert('g', ':first-child')
            .classed('orbit2', true)
            .attr('transform', d3Transform().rotate(0, width / 2, offsetY))
            
            var rootGroup = canvas.append("g");
            rootGroup.attr("transform", "translate(" + offsetX + "," + offsetY + ")");

            var data = Object.assign({children: children}, parent.data);
            var subTree = d3.hierarchy(data);
            subTree.data = parent.parent.data;
            
            // calc start angle
            var arcDeg = layout_orbit(subTree, {
              start: START_ANGEL,
              end: 180 - START_ANGEL,
              radius: radius,
              canvasRadius: width / 2,
              margin: MARGIN_ANGEL / 2
            }).deg;
            var startDeg;
            var parentDeg = parent.x - START_ANGEL;
            var totalDeg = 180 - START_ANGEL * 2;
            if (arcDeg / 2 < parentDeg) {
              startDeg = parentDeg - arcDeg / 2;
            } else if (arcDeg / 2 > parentDeg) {
              startDeg = 0;
            }
            startDeg += START_ANGEL;
            // calc start angle
            var result = layout_orbit(subTree, {
              start: startDeg,
              end: 180 - START_ANGEL,
              radius: radius,
              canvasRadius: width / 2,
              margin: MARGIN_ANGEL / 2
            });

            var nodes = subTree.descendants().slice(1);
            var links = subTree.links();
            var link = rootGroup.selectAll('.link')
            .data(nodes, function(d) {
              return d.data.id;
            });

            // Enter any new links at the parent's previous position.
            var linkEnter = link.enter().append('path')
            .attr('class', 'link')
            .attr('d', function(d) {
              // origin and endpoint are the same
              return 'M' + parent.circle.peak + 'L' + parent.circle.peak;
            });

            var linkUpdate = link.merge(linkEnter)
            .transition()
            .delay(DURATION / 2)
            .duration(DURATION / 2)
            .ease(d3.easeQuadOut)
            .attr('d', function(d, i) {
              // origin: circle peak of parent (named `node` here)
              // endpoint: circle center of current node
              return 'M' + parent.circle.peak + 'L' + d.circle.center;
              // var controlPos = [
              //   sourcePos[0] + (targetPos[0] - sourcePos[0]) * 0.4,
              //   sourcePos[1] + (targetPos[1] - sourcePos[1]) * 0.65
              // ];
              // return 'M' + source.circle.peak + 'Q' + controlPos + ',' + d.circle.center;
            });
            var groups = rootGroup.selectAll('g.node')
            .data(nodes, function(d) {
              return d.data.id || (
                  d.data.id = ++i
                )
            });

            var nodeEnter = groups.enter().append("g")
            .attr('class', function(d) {
              return 'node ' + (
                  d.children ? 'node--internal' : 'node--leaf'
                );
            })
            .attr("transform", function(d) {
              // original position (parent `node` circle center)
              return 'translate(' + parent.circle.center + ')';
            })
            .attr('id', function(d) {
              return 'node-' + d.data.id;
            })
            .each(renderNode);

            // Transition nodes to their new position.
            var nodeUpdate = groups.merge(nodeEnter)
            .transition()
            .duration(DURATION / 2)
            .attr('transform', function(d) {
              // own position
              return 'translate(' + d.circle.center + ')';
            });

            return Object.assign(result, {
              element: canvas,
              close: function closeNode() {
                return new Promise(function(resolve, reject) {
                  var root = svg.select('.orbit2.curr-page');
                  var nodes = root.selectAll('g.node');
                  var links = root.selectAll('path.link');

                  nodes.transition()
                  .duration(DURATION / 2)
                  .attr('transform', function(d) {
                    // back to original position (parent `node` circle center)
                    return 'translate(' + parent.circle.center + ')';
                  })
                  .on('end', function(d, i) {
                    // when orbit 2 is closed
                    if (i === 0) {
                      root.remove();
                      resolve();
                    }
                  });

                  links.transition()
                  .duration(DURATION / 2)
                  .attr('d', function(d) {
                    // back to original position (parent `node` circle peak)
                    return 'M' + parent.circle.peak + 'L' + parent.circle.peak;
                  });
                });
              }
            });
          },
          // dynamic function later bind in "renderCurrPage"
          closeNodeL1: function() {
            return Promise.resolve();
          },
          // dynamic function later bind in "plotL1"
          resetOrbitL1: function() {
            var svg = d3.select(this.$.chartSvg);
            var root = svg.selectAll('.orbit1.curr-page');
            // reset to render subtree
            root.selectAll('g.node').filter(function(d) {
              return d.parent;
            })
            .transition()
            .duration(DURATION)
            .attr('transform', function(d) {
              // move to original position
              return 'translate(' + d.circle0.center + ')';
            })
            .each(function(d, i, nodeList) {
              // reset the gauge size and position
              d3.select(nodeList[i])
              .select('g.gauge')
              .transition()
              .duration(DURATION)
              .attr('transform', function(d) {
                var pos = [d.size, d.size].map(function(n) {
                  return -n;
                });
                return 'translate(' + pos.join(',') + ')';
              });
            });
            root.selectAll('.link')
            .transition()
            .duration(DURATION)
            .attr('d', function(d) {
              // origin: circle0 peak of parent
              // endpoint: circle0 center of current node
              // circle0 is an alias of the previous circle
              return 'M' + d.parent.circle0.peak + 'L' + d.circle0.center;
            });
          },
          handleOpenNode: function(node) {
            var _this = this;
            // check if the node is already opened
            if (this.openingNodeL1 && this.openingNodeL1.data.id == node.data.id) {
              return false;
            }
            _this.openingNodeL1 = node;

            // TODO: fetch real node url
            var key = 'mock/profit-2016-type-MRI.json';
            _this.loadData(key).then(function() {
              var close = _this.renderCurrPage(key, 2).close;
              _this.closeNodeL1 = function() {
                return close().then(function() {
                  _this.plotPager(key, 1);
                });
              }
            });
          },
          _computeLastStartL1: function() {
            var history = this._pageStartHistoryL1;
            this.pageLastStartL1 = history[history.length - 1];
          },
          _computeLastStartL2: function() {
            var history = this._pageStartHistoryL2;
            this.pageLastStartL2 = history[history.length - 1];
          },
          _pageChangedL1: function(newVal, oldVal) {
            // on page changed build the offset history, in order to navigate backwards.
            if (oldVal === undefined || newVal > oldVal) {
              this.push('_pageStartHistoryL1', oldVal);
            } else {
              this.pop('_pageStartHistoryL1');
            }
          },
          _pageChangedL2: function(newVal, oldVal) {
            // on page changed build the offset history, in order to navigate backwards.
            if (oldVal === undefined || newVal > oldVal) {
              this.push('_pageStartHistoryL2', oldVal);
            } else {
              this.pop('_pageStartHistoryL2');
            }
          },
          // Load next "n" more items from the URL and add them to cache
          loadData: function(url, n) {
            var _this = this;
            n = n || PAGINATION_BUFFER;
            var cacheKey = url;
            var list = lscache.get(cacheKey) || [];
            var pages = lscache.get(cacheKey + '/pages');
            var length = list.length || 0;

            // read the furthest offset
            if (!pages || length < pages.total) {
              url = URI(url).addQuery({
                'start': length,
                'limit': n
              }).toString();
              return fetch(url).then(function(res) {
                return res.json();
              }).then(function(data) {
                list = list.concat(data.items.map(formatConvert));
                lscache.set(cacheKey, list);
                lscache.set(cacheKey + '/root', formatConvert(data.root));
                lscache.set(cacheKey + '/pages', data.pages);
              });
            } {
              return Promise.resolve();
            }
          },
          renderCurrPage: function(key, level) {
            level = level || 1;
            var parent;
            // plot root on level1
            if (level === 1) {
              parent = lscache.get(key + '/root');
              this.plotRoot(parent);
            } else {
              parent = this.openingNodeL1;
            }
            var start = this.get('pageStartL' + level);
            var list = lscache.get(key) || [];
            list = list.slice(start);
            this.removePage('curr', level);
            var result = this['plotL' + level].call(this, parent, list);
            result.element.classed('curr-page', true);
            this.set('pageOffsetL' + level, result.count);
            this.renderNextPage(key, level);
            this.renderPrevPage(key, level);
            this.plotPager(key, level);
            return result;
          },
          renderNextPage: function(key, level) {
            var offset = this.get('pageOffsetL' + level);
            var list = lscache.get(key) || [];
            var result;
            var parent;
            // check if next page exists
            if (list.length > offset) {
              list = list.slice(offset);
              // plot root on level1
              if (level === 1) {
                parent = lscache.get(key + '/root');
                this.plotRoot(parent);
              } else {
                parent = this.openingNodeL1;
              }
              result = this['plotL' + level].call(this, parent, list);
              result.element.classed('next-page', true).attr('transform', rotate(90));
              this.set('pageEndL'+level, offset + result.count);
            }
          },
          renderPrevPage: function(key, level) {
            var start = this.get('pageLastStartL' + level),
              end = this.get('pageStartL' + level),
              list = lscache.get(key) || [],
              result,
              parent;

            if (!isNaN(start)) {
              list = list.slice(start, end);
              // plot root on level1
              if (level === 1) {
                parent = lscache.get(key + '/root');
                this.plotRoot(parent);
              } else {
                parent = this.openingNodeL1;
              }

              result = this['plotL' + level].call(this, parent, list);
              result.element.classed('prev-page', true).attr('transform', rotate(-90));
            }
          },
          openNextPage: function(key, level) {
            var _this = this;

            // move page offset counter-clockwise
            this.set('pageStartL' + level, this.get('pageOffsetL' + level));
            this.set('pageOffsetL' + level, this.get('pageEndL' + level));
            delete this['pageEndL' + level];

            // load next page
            _this.loadData(key).then(function() {
              _this.renderNextPage(key, level);
            });

            d3.select('.orbit' + level + '.next-page')
            .transition()
            .duration(DURATION_PAGING)
            .style('opacity', 1)
            .attrTween('transform', rotateToTween(0))
            .on('start', function() {
              _this.isPaging = true;
            })
            .on('end', function() {
              pageEntered.call(this, 'curr');
              _this.isPaging = false;
              _this.plotPager(key, level);
            });

            d3.select('.orbit' + level + '.curr-page')
            .transition()
            .style('opacity', 0)
            .duration(DURATION_PAGING)
            .attrTween('transform', rotateToTween(-90))
            .on('end', function() {
              pageEntered.call(this, 'prev');
              // reconcile dom
              _this.scopeSubtree(this);
            });

            // kick out previous
            d3.select('.orbit' + level + '.prev-page').remove();
          },
          openPrevPage: function(key, level) {
            var _this = this;

            // move page offset clockwise
            this.set('pageEndL' + level, this.get('pageOffsetL' + level));
            this.set('pageOffsetL' + level, this.get('pageStartL' + level));
            this.set('pageStartL' + level, this.get('pageLastStartL' + level));

            // load prev page
            this.renderPrevPage(key, level);

            d3.select('.orbit' + level + '.prev-page')
            .transition()
            .duration(DURATION_PAGING)
            .style('opacity', 1)
            .attrTween('transform', rotateToTween(0))
            .on('start', function() {
              _this.isPaging = true;
            })
            .on('end', function() {
              _this.isPaging = false;
              _this.plotPager(key, level);

              pageEntered.call(this, 'curr');
              // reconcile dom
              _this.scopeSubtree(this);
            });

            d3.select('.orbit' + level + '.curr-page')
            .transition()
            .style('opacity', 0)
            .duration(DURATION_PAGING)
            .attrTween('transform', rotateToTween(90))
            .on('end', function() {
              pageEntered.call(this, 'next');
              // reconcile dom
              _this.scopeSubtree(this);
            });

            // kick out next
            d3.select('.orbit' + level + '.next-page').remove();
          },
          removePage: function(type, level) {
            var $page = d3.select(this.$.chartSvg).select('.orbit'+level+'.'+type+'-page');
            $page.remove();
          },
          enterLeavePaging: function() {
            d3.select(this.$.chartSvg).classed('in-transition', this.isPaging);
          },
          ready: function() {
            var _this = this;
            var rect = this.$.chart.getBoundingClientRect();
            this.set('width', rect.width);
            this.set('height', rect.height);
            var url = 'mock/profit-2016-by-type.json';
            this.loadData(url).then(function() {
              _this.renderCurrPage(url);
            });
          }
        });
      }
    )();
  </script>
</dom-module>